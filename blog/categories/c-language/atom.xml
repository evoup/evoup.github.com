<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c-language | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/c-language/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2016-08-03T15:39:48+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Evoup`s Blog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VS2010 LINK:fatal error LNK1123]]></title>
    <link href="http://evoupsight.com/blog/2014/02/10/vs2010-link-fatal-error-lnk1123/"/>
    <updated>2014-02-10T15:22:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/02/10/vs2010-link-fatal-error-lnk1123</id>
    <content type="html"><![CDATA[<p>因为要看cocostudio的实例代码，在原有vs2010的基础上又安装了vs2012，出现了项目不能编译的问题OMG
` LINK : fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏 `
以下为解决方法：</p>

<!-- more -->

<blockquote>
  <p>VS2010在经历一些更新后，建立Win32 Console Project时会出“error LNK1123” 错误，解决方案为将 项目|项目属性|配置属性|清单工具|输入和输出|嵌入清单 “是”改为“否”即可，但是没新建一个项目都要这样设置一次。
在建立VS2010 Win32 Project项目时，按照上面解决方案依然发生了“error LNK1123”错误，经过上网查资料，解决方案为：
第一步：与上相同。
第二步：将 项目|项目属性|配置属性|连接器|清单文件|嵌入清单 “是”改为“否”。
第三步：一般计算机经过上两步设置就能解决问题了，但是如果还有问题，那就按一下方法解决：
计算机是否为64bit操作系统，如是，继续2。
查找是否有两个cvtres.exe。一个是C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\cvtres.exe， 另一个是C:\Windows\Microsoft.NET\Framework\v4.0.30319\cvtres.exe。右键属性|详细信息 查看两者版本号，删除/重命名较旧的版本，或者重新设置Path变量。
删除或者重命名比较旧的版本的cvtres.exe即可。</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何正确地把带参数的C语言main程序改成so]]></title>
    <link href="http://evoupsight.com/blog/2013/11/19/change-c-program-to-so/"/>
    <updated>2013-11-19T18:17:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/11/19/change-c-program-to-so</id>
    <content type="html"><![CDATA[<p>首先有些标题党吧，不过个人体会修改程序的过程中遇到未知的坑还是比较阴险的，所以整理一下写个博客。</p>

<p>之前尝试把C语言的带参数执行的main程序改成动态链接库，发生了一个问题，主程序调用动态链接库最后获取的结果保持不变，跑了一会儿之后还是和第一次调用的一样。把几乎可能导致问题的static变量全部给改为非静态变量和重置后居然还是无效。最后在痛苦的查询资料之后，终于找到了问题所在。</p>

<p>话说回来，先看怎么把带参main程序改成动态链接库。</p>

<!-- more -->

<p>先看准备被改成动态库的原代码
{% codeblock test.c lang:c %}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char **argv) {
    int ch;
    const char *opts="a:b::cd";
    while ((ch = getopt(argc, argv, opts)) != -1) {
        switch (ch) {
        case 'a':
            printf("option a:'%s'\n",optarg);
            break;
        case 'b':
            printf("option b:'%s'\n",optarg);
            break;
        case 'c':
            printf("option c:'%s'\n",optarg);
            break;
        case 'd':
            printf("option d:'%s'\n",optarg);
            break;
        default:
            printf("other option:%c\n",ch);
        }
    }
}
{% endcodeblock %}</unistd.h></stdlib.h></stdio.h></p>

<p><code>makefile
gcc -Wall test.c -o test
</code></p>

<p>测试：</p>

<p><code>sh
./test -a1 -b1 -c -d
option a:'1'
option b:'1'
option c:'(null)'
option d:'(null)'
</code></p>

<p>稍微讲下getopt的用法，这个命令是提供命令行执行可执行程序带不同参数的功能实现。以上程序根据所数入的参数，执行相应的操作。
其中opts的a:b::cd，“:”表示必须该选项带有额外的参数，全局变量optarg会指向此额外参数，“::”标识该额外的参数可选(有些Uinx可能不支持“::”）。</p>

<p>接下来把它给改成SO，然后再主调程序中直接指定参数进行调用。
{% codeblock plug.c lang:c %}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int dlmain(int, char **);
int main(int argc, char **argv) {
    char *cmdStr[5]={"","-a1","-b1","-c","-d\0"};
    dlmain(5,cmdStr);
    return 1;
}
int dlmain(int argc, char **argv) {
    int ch;
    const char *opts="a:b::cd";
    while ((ch = getopt(argc, argv, opts)) != -1) {
        switch (ch) {
        case 'a':
            printf("option a:'%s'\n",optarg);
            break;
        case 'b':
            printf("option b:'%s'\n",optarg);
            break;
        case 'c':
            printf("option c:'%s'\n",optarg);
            break;
        case 'd':
            printf("option d:'%s'\n",optarg);
            break;
        default:
            printf("other option:%c\n",ch);
        }
    }
    printf("in dll\n");
    return 1;
}
{% endcodeblock %}</unistd.h></stdlib.h></stdio.h></p>

<p>测试一下</p>

<p><code>makefile
gcc -Wall plug.c -o plug
./plug
option a:'1'
option b:'1'
option c:'(null)'
option d:'(null)'
in dll
</code></p>

<p>ok，没有问题，直接转换成动态库
{% codeblock plug.c lang:c %}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int d_plug ();
int dlmain(int, char **);
int d_plug () {
    char *cmdStr[5]={"","-a1","-b1","-c","-d\0"};
    dlmain(5,cmdStr);
    return 1;
}
int dlmain(int argc, char **argv) {
    int ch;
    const char *opts="a:b::cd";
    while ((ch = getopt(argc, argv, opts)) != -1) {
        switch (ch) {
        case 'a':
            printf("option a:'%s'\n",optarg);
            break;
        case 'b':
            printf("option b:'%s'\n",optarg);
            break;
        case 'c':
            printf("option c:'%s'\n",optarg);
            break;
        case 'd':
            printf("option d:'%s'\n",optarg);
            break;
        default:
            printf("other option:%c\n",ch);
        }
    }
    printf("in dll\n");
    return 1;
}
{% endcodeblock %}</unistd.h></stdlib.h></stdio.h></p>

<p>编译动态连接库</p>

<p><code>makefile
gcc -shared -o plug.so plug.c -fpic
</code></p>

<p>这样就得到了plug.so</p>

<p>接下来写主调程序，用它直接调用已经封装好的plug.so动态库。
{% codeblock main.c lang:c %}
#include <stdio.h>
#include <dlfcn.h>
int (*d_plug) ();
int main(int argc,char **argv) {
    void *dp;
    dp=dlopen("./plug.so",RTLD_LAZY);
    d_plug=dlsym(dp,"d_plug");
    d_plug();
    dlclose(dp);
    return 1;
}
{% endcodeblock %}
编译执行看结果</dlfcn.h></stdio.h></p>

<p><code>makefile
gcc main.c -lc -fpic -o main
./main
option a:'1'
option b:'1'
option c:'(null)'
option d:'(null)'
in dll
</code></p>

<h3 id="section">其他注意事项：</h3>
<p>其实除了optarg，还存在全局变量optind、opterror和optopt。三者的作用</p>

<p>optarg：非常明了，就是指程序的参数，是个字符串指针</p>

<p>optind：是下一次调用getopt的时，从optind存储的位置处重新开始检查选项</p>

<p>opterr：当opterr=0时，getopt不向stderr输出错误信息</p>

<p>optopt: 当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt 中，getopt返回’？’</p>

<h3 id="section-1">问题解决:</h3>
<p>写erlang的NIF扩展时optind需要重置为0，否则就导致了每次结果不变，因为就我所知erlang目前版本的NIF是没有unload功能的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Freebsd版linux下free指令实现]]></title>
    <link href="http://evoupsight.com/blog/2013/10/30/freebsd-memory-free-c/"/>
    <updated>2013-10-30T16:41:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/10/30/freebsd-memory-free-c</id>
    <content type="html"><![CDATA[<p>监控客户端开发时候用到的代码，github上一个哥么的，发现有处bug我给贡献了，呵呵。
<!-- more -->
直接贴代码了，除了mem_total之外基本都正确。total的部分，先用sysctl -a | grep realmem解决</p>

<p>{% codeblock lang:c free.c %}
/*
 * free.c - Display FreeBSD memory information
 * Wed Nov 26 19:34:54 IST 2008 vinod <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#118;&#105;&#110;&#111;&#100;&#064;&#115;&#101;&#103;&#102;&#097;&#117;&#108;&#116;&#046;&#105;&#110;">&#118;&#105;&#110;&#111;&#100;&#064;&#115;&#101;&#103;&#102;&#097;&#117;&#108;&#116;&#046;&#105;&#110;</a>
 * License: http://opensource.org/licenses/BSD-2-Clause
 */</p>

<h1 id="include-systypesh">include &lt;sys/types.h&gt;</h1>
<p>#include &lt;sys/sysctl.h&gt;
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h /></stdlib.h></stdio.h></p>

<p>const char *version = “$Id: free,v 0.1.3 2008/11/26 19:34:54 IST vinod $”;</p>

<p>int
get_sysctl(char *name)
{
        int mib[4], value, i;
        size_t len, miblen = 1;</p>

<pre><code>    for(i = 0; name[i] != '\0'; i++) 
            if(name[i] == '.')
                    miblen++;
    len = miblen;
    sysctlnametomib(name, mib, &amp;len);
    len = sizeof(value);
    sysctl(mib, miblen, &amp;value, &amp;len, NULL, 0);

    return value; }
</code></pre>

<p>void
usage(void)
{
        fprintf(stderr, “usage: free [-b|-k|-m|-g] [-t] [-v]\n” \
        “  -b,-k,-m,-g show output in bytes, KB, MB, or GB\n” \
        “  -t display logical summary for RAM\n” \
        “  -v display version information and exit\n”);
}</p>

<p>int
main(int argc, char *argv[])
{
        int c, vflag = 0, tflag = 0;
        int factor = 1;
        long int physmem, realmem;
        long int vmactive, vminactive, vmfree, vmcache, vmpage, vmwire;
        long int memfree, memused;
        long int pagesize;</p>

<pre><code>    opterr = 0;

    while ((c = getopt(argc, argv, "bghkmtv")) != -1) {
            switch (c) {
                    case 'b':
                            factor = 1;
                            break;
                    case 'g':
                            factor = 1024*1024*1024;

                    case 'h':
                            usage();
                            exit(EXIT_SUCCESS);
                    case 'k':
                            factor = 1024;
                            break;
                    case 'm':
                            factor = 1024*1024;
                            break;
                    case 't':
                            tflag = 1;
                            break;
                    case 'v':
                            vflag = 1;
                            break;
                    case '?':
                    default:
                            fprintf(stderr, "%s: invalid option -- %c\n", argv[0], optopt);
                            usage();
                            exit(EXIT_FAILURE);
            }
    }

    argc -= optind;
    argv += optind;

    if(vflag) {
            fprintf(stderr, "%s\nbuilt %s %s\n", version,
                            __DATE__, __TIME__);
            exit(EXIT_SUCCESS);
    }

    physmem    = labs(get_sysctl("hw.physmem"));
    realmem    = labs(get_sysctl("hw.realmem"));
    pagesize   = labs(get_sysctl("hw.pagesize"));

    vmpage     = labs(get_sysctl("vm.stats.vm.v_page_count") * pagesize);
    vmwire     = labs(get_sysctl("vm.stats.vm.v_wire_count") * pagesize);
    vmactive   = labs(get_sysctl("vm.stats.vm.v_active_count") * pagesize);
    vminactive = labs(get_sysctl("vm.stats.vm.v_inactive_count") * pagesize);
    vmcache    = labs(get_sysctl("vm.stats.vm.v_cache_count") * pagesize);
    vmfree     = labs(get_sysctl("vm.stats.vm.v_free_count") * pagesize);

    printf("         %15s %15s %15s %15s %15s %15s\n", "total", "active", "free", "inactive", "wire", "cached");
    printf("Memory:  %15ld %15ld %15ld %15ld %15ld %15ld\n",
                    realmem/factor,
                    vmactive/factor,
                    vmfree/factor,
                    vminactive/factor,
                    vmwire/factor,
                    vmcache/factor);

    /*
     * logical summary
     */
    if(tflag) {
            memfree = vminactive + vmfree + vmcache;
            memused        = realmem - memfree;

            printf("Summary: %15ld %15ld %15ld\n",
                            realmem/factor,
                            memused/factor,
                            memfree/factor);
    }

    return (EXIT_SUCCESS); } {% endcodeblock %}
</code></pre>

<h3 id="section">项目位置</h3>

<p>https://github.com/evoup/free</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下模拟df.c源码]]></title>
    <link href="http://evoupsight.com/blog/2013/10/16/linux-df-source-c-code/"/>
    <updated>2013-10-16T18:09:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/10/16/linux-df-source-c-code</id>
    <content type="html"><![CDATA[<p>主要实现df的基本不带参数的功能，连界面都不一样，凑活用，见代码：</p>

<!-- more -->

<p>```c
#include <stdio.h>
#include <stdlib.h>
#include <mntent.h>
#include &lt;sys/vfs.h&gt;</mntent.h></stdlib.h></stdio.h></p>

<p>int main(void)
{
 struct mntent *ent;
 FILE *aFile;</p>

<p>aFile = setmntent(“/etc/mtab”, “r”);
 if (aFile == NULL) {
   perror(“setmntent”);
   exit(1);
 }
 struct statfs diskInfo;
 unsigned long long blocksize;
 unsigned long long totalsize;
 unsigned long long freeDisk;
 unsigned long long availsize;
 unsigned long long used;
 while (NULL != (ent = getmntent(aFile))) { //获取各挂载点的信息
   printf(“=========================================================================\
==================================================\n”);
   //根据挂载点，确认磁盘空间
   statfs(ent-&gt;mnt_dir,&amp;diskInfo);
   blocksize = diskInfo.f_bsize; //每个block里面包含的字节数
   totalsize = blocksize * diskInfo.f_blocks; //总的字节数
   freeDisk = diskInfo.f_bfree<em>blocksize; //再计算下剩余的空间大小
   availsize = diskInfo.f_bavail</em>blocksize;
   //&gt;10换算成KB
   used=totalsize-freeDisk;
   printf(“FS == %s MOUNTPOINT == %s TOTAL_SIZE == %lu KB DISK_FREE == %ld KB USED ==\
%ld KB avail == %ld KB\n”, ent-&gt;mnt_fsname, ent-&gt;mnt_dir,(int)(totalsize»10),
(int)(freeDisk»10),(int)(used»10),(int)(availsize»10));
 }
 endmntent(aFile);
   printf(“=========================================================================\
==================================================\n”);
}
```</p>

<p>附一张运行截图
<img src="/images/evoup/df.png" alt="Alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言变参宏]]></title>
    <link href="http://evoupsight.com/blog/2011/06/05/lighttpd-change-parameter-define/"/>
    <updated>2011-06-05T23:29:00+08:00</updated>
    <id>http://evoupsight.com/blog/2011/06/05/lighttpd-change-parameter-define</id>
    <content type="html"><![CDATA[<p>研究lighttpd1.4.28代码的时候，到缓存调用部分，有这么一句：</p>

<p><code>c
buffer_copy_string_len(modules-&gt;key, CONST_STR_LEN("server.modules"));
</code>
而此参数声明的时候是这样的</p>

<p><code>c
int buffer_copy_string_len(buffer *b, const char *s, size_t s_len);
</code>
怎么是三个参？从CONST_STR_LEN入手，这是一个宏</p>

<p><code>c
#define CONST_STR_LEN(x) x, x ? sizeof(x) - 1 : 0
</code>
这不就成了三个参了？记一笔…</p>
]]></content>
  </entry>
  
</feed>
