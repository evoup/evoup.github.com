<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c-language | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/c-language/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2013-11-19T16:01:45+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Freebsd版linux下free指令实现]]></title>
    <link href="http://evoupsight.com/blog/2013/10/30/freebsd-memory-free-c/"/>
    <updated>2013-10-30T16:41:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/10/30/freebsd-memory-free-c</id>
    <content type="html"><![CDATA[<p>监控客户端开发时候用到的代码，github上一个哥么的，发现有处bug我给贡献了，呵呵。</p>

<!-- more -->


<p>直接贴代码了，除了mem_total之外基本都正确。total的部分，先用sysctl -a | grep realmem解决
```c
/<em>
 * free.c &ndash; Display FreeBSD memory information
 * Wed Nov 26 19:34:54 IST 2008 vinod <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#118;&#x69;&#110;&#111;&#100;&#64;&#x73;&#101;&#103;&#102;&#x61;&#117;&#108;&#116;&#46;&#x69;&#110;">&#118;&#105;&#110;&#111;&#100;&#x40;&#x73;&#101;&#x67;&#102;&#x61;&#117;&#108;&#116;&#x2e;&#x69;&#x6e;</a>
 * License: <a href="http://opensource.org/licenses/BSD-2-Clause">http://opensource.org/licenses/BSD-2-Clause</a>
 </em>/</p>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;sys/sysctl.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<p>const char *version = &ldquo;$Id: free,v 0.1.3 2008/11/26 19:34:54 IST vinod $&rdquo;;</p>

<p>int
get_sysctl(char *name)
{</p>

<pre><code>    int mib[4], value, i;
    size_t len, miblen = 1;

    for(i = 0; name[i] != '\0'; i++) 
            if(name[i] == '.')
                    miblen++;
    len = miblen;
    sysctlnametomib(name, mib, &amp;len);
    len = sizeof(value);
    sysctl(mib, miblen, &amp;value, &amp;len, NULL, 0);

    return value;
</code></pre>

<p>}</p>

<p>void
usage(void)
{</p>

<pre><code>    fprintf(stderr, "usage: free [-b|-k|-m|-g] [-t] [-v]\n" \
    "  -b,-k,-m,-g show output in bytes, KB, MB, or GB\n" \
    "  -t display logical summary for RAM\n" \
    "  -v display version information and exit\n");
</code></pre>

<p>}</p>

<p>int
main(int argc, char *argv[])
{</p>

<pre><code>    int c, vflag = 0, tflag = 0;
    int factor = 1;
    long int physmem, realmem;
    long int vmactive, vminactive, vmfree, vmcache, vmpage, vmwire;
    long int memfree, memused;
    long int pagesize;

    opterr = 0;

    while ((c = getopt(argc, argv, "bghkmtv")) != -1) {
            switch (c) {
                    case 'b':
                            factor = 1;
                            break;
                    case 'g':
                            factor = 1024*1024*1024;

                    case 'h':
                            usage();
                            exit(EXIT_SUCCESS);
                    case 'k':
                            factor = 1024;
                            break;
                    case 'm':
                            factor = 1024*1024;
                            break;
                    case 't':
                            tflag = 1;
                            break;
                    case 'v':
                            vflag = 1;
                            break;
                    case '?':
                    default:
                            fprintf(stderr, "%s: invalid option -- %c\n", argv[0], optopt);
                            usage();
                            exit(EXIT_FAILURE);
            }
    }

    argc -= optind;
    argv += optind;

    if(vflag) {
            fprintf(stderr, "%s\nbuilt %s %s\n", version,
                            __DATE__, __TIME__);
            exit(EXIT_SUCCESS);
    }

    physmem    = labs(get_sysctl("hw.physmem"));
    realmem    = labs(get_sysctl("hw.realmem"));
    pagesize   = labs(get_sysctl("hw.pagesize"));

    vmpage     = labs(get_sysctl("vm.stats.vm.v_page_count") * pagesize);
    vmwire     = labs(get_sysctl("vm.stats.vm.v_wire_count") * pagesize);
    vmactive   = labs(get_sysctl("vm.stats.vm.v_active_count") * pagesize);
    vminactive = labs(get_sysctl("vm.stats.vm.v_inactive_count") * pagesize);
    vmcache    = labs(get_sysctl("vm.stats.vm.v_cache_count") * pagesize);
    vmfree     = labs(get_sysctl("vm.stats.vm.v_free_count") * pagesize);

    printf("         %15s %15s %15s %15s %15s %15s\n", "total", "active", "free", "inactive", "wire", "cached");
    printf("Memory:  %15ld %15ld %15ld %15ld %15ld %15ld\n",
                    realmem/factor,
                    vmactive/factor,
                    vmfree/factor,
                    vminactive/factor,
                    vmwire/factor,
                    vmcache/factor);

    /*
     * logical summary
     */
    if(tflag) {
            memfree = vminactive + vmfree + vmcache;
            memused        = realmem - memfree;

            printf("Summary: %15ld %15ld %15ld\n",
                            realmem/factor,
                            memused/factor,
                            memfree/factor);
    }

    return (EXIT_SUCCESS);
</code></pre>

<p>}
```</p>

<h3>项目位置</h3>

<p><a href="https://github.com/evoup/free">https://github.com/evoup/free</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下模拟df.c源码]]></title>
    <link href="http://evoupsight.com/blog/2013/10/16/linux-df-source-c-code/"/>
    <updated>2013-10-16T18:09:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/10/16/linux-df-source-c-code</id>
    <content type="html"><![CDATA[<p>主要实现df的基本不带参数的功能，连界面都不一样，凑活用，见代码：</p>

<!-- more -->


<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;mntent.h></h1>

<h1>include &lt;sys/vfs.h></h1>

<p>int main(void)
{
 struct mntent <em>ent;
 FILE </em>aFile;</p>

<p> aFile = setmntent(&ldquo;/etc/mtab&rdquo;, &ldquo;r&rdquo;);
 if (aFile == NULL) {
   perror(&ldquo;setmntent&rdquo;);
   exit(1);
 }
 struct statfs diskInfo;
 unsigned long long blocksize;
 unsigned long long totalsize;
 unsigned long long freeDisk;
 unsigned long long availsize;
 unsigned long long used;
 while (NULL != (ent = getmntent(aFile))) { //获取各挂载点的信息
   printf(&ldquo;=========================================================================\
==================================================\n&rdquo;);
   //根据挂载点，确认磁盘空间
   statfs(ent->mnt_dir,&amp;diskInfo);
   blocksize = diskInfo.f_bsize; //每个block里面包含的字节数
   totalsize = blocksize * diskInfo.f_blocks; //总的字节数
   freeDisk = diskInfo.f_bfree<em>blocksize; //再计算下剩余的空间大小
   availsize = diskInfo.f_bavail</em>blocksize;
   //>10换算成KB
   used=totalsize-freeDisk;
   printf(&ldquo;FS == %s MOUNTPOINT == %s TOTAL_SIZE == %lu KB DISK_FREE == %ld KB USED ==\
%ld KB avail == %ld KB\n&rdquo;, ent->mnt_fsname, ent->mnt_dir,(int)(totalsize>>10),
(int)(freeDisk>>10),(int)(used>>10),(int)(availsize>>10));
 }
 endmntent(aFile);
   printf(&ldquo;=========================================================================\
==================================================\n&rdquo;);
}
```</p>

<p>附一张运行截图
<img src="/images/evoup/df.png" alt="Alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言变参宏]]></title>
    <link href="http://evoupsight.com/blog/2011/06/05/lighttpd-change-parameter-define/"/>
    <updated>2011-06-05T23:29:00+08:00</updated>
    <id>http://evoupsight.com/blog/2011/06/05/lighttpd-change-parameter-define</id>
    <content type="html"><![CDATA[<p>研究lighttpd1.4.28代码的时候，到缓存调用部分，有这么一句：</p>

<p><code>c
buffer_copy_string_len(modules-&gt;key, CONST_STR_LEN("server.modules"));
</code>
而此参数声明的时候是这样的</p>

<p><code>c
int buffer_copy_string_len(buffer *b, const char *s, size_t s_len);
</code>
怎么是三个参？从CONST_STR_LEN入手，这是一个宏</p>

<p>```c</p>

<h1>define CONST_STR_LEN(x) x, x ? sizeof(x) &ndash; 1 : 0</h1>

<p>```
这不就成了三个参了？记一笔&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言宏定义技巧(常用宏定义)(转)]]></title>
    <link href="http://evoupsight.com/blog/2011/01/16/c-common-define/"/>
    <updated>2011-01-16T13:43:00+08:00</updated>
    <id>http://evoupsight.com/blog/2011/01/16/c-common-define</id>
    <content type="html"><![CDATA[<p>写好C语言，漂亮的宏定义很重要，使用宏定义可以防止出错，提高可移植性，可读性，方便性 等等。下面列举一些成熟软件中常用得宏定义。。。。。。</p>

<p>1，防止一个头文件被重复包含
```c</p>

<h1>ifndef COMDEF_H</h1>

<h1>define COMDEF_H</h1>

<p>//头文件内容</p>

<h1>endif</h1>

<p>```</p>

<!-- more -->


<p>2，重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。
<code>c
typedef unsigned char boolean; /* Boolean value type. */
typedef unsigned long int uint32; /* Unsigned 32 bit value */
typedef unsigned short uint16; /* Unsigned 16 bit value */
typedef unsigned char uint8; /* Unsigned 8 bit value */
typedef signed long int int32; /* Signed 32 bit value */
typedef signed short int16; /* Signed 16 bit value */
typedef signed char int8; /* Signed 8 bit value */
</code></p>

<p>//下面的不建议使用
<code>c
typedef unsigned char byte; /* Unsigned 8 bit value type. */
typedef unsigned short word; /* Unsinged 16 bit value type. */
typedef unsigned long dword; /* Unsigned 32 bit value type. */
typedef unsigned char uint1; /* Unsigned 8 bit value type. */
typedef unsigned short uint2; /* Unsigned 16 bit value type. */
typedef unsigned long uint4; /* Unsigned 32 bit value type. */
typedef signed char int1; /* Signed 8 bit value type. */
typedef signed short int2; /* Signed 16 bit value type. */
typedef long int int4; /* Signed 32 bit value type. */
typedef signed long sint31; /* Signed 32 bit value */
typedef signed short sint15; /* Signed 16 bit value */
typedef signed char sint7; /* Signed 8 bit value */
</code></p>

<p>3，得到指定地址上的一个字节或字
```c</p>

<h1>define MEM_B( x ) ( <em>( (byte </em>) (x) ) )</h1>

<h1>define MEM_W( x ) ( <em>( (word </em>) (x) ) )</h1>

<p>```</p>

<p>4，求最大值和最小值
```c</p>

<h1>define MAX( x, y ) ( ((x) > (y)) ? (x) : (y) )</h1>

<h1>define MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )</h1>

<p>```</p>

<p>5，得到一个field在结构体(struct)中的偏移量
```c</p>

<h1>define FPOS( type, field ) \</h1>

<p>/<em>lint -e545 </em>/ ( (dword) &amp;(( type <em>) 0)&ndash;> field ) /</em>lint +e545 */
```</p>

<p>6,得到一个结构体中field所占用的字节数
```c</p>

<h1>define FSIZ( type, field ) sizeof( ((type *) 0)&ndash;>field )</h1>

<p>```</p>

<p>7，按照LSB格式把两个字节转化为一个Word
```c</p>

<h1>define FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )</h1>

<p>```</p>

<p>8，按照LSB格式把一个Word转化为两个字节
```c</p>

<h1>define FLOPW( ray, val ) \</h1>

<p>(ray)[0] = ((val) / 256); \</p>

<p>(ray)[1] = ((val) &amp; 0xFF)
```</p>

<p>9，得到一个变量的地址（word宽度）
```c</p>

<h1>define B_PTR( var ) ( (byte <em>) (void </em>) &amp;(var) )</h1>

<h1>define W_PTR( var ) ( (word <em>) (void </em>) &amp;(var) )</h1>

<p>```</p>

<p>10，得到一个字的高位和低位字节
```c</p>

<h1>define WORD_LO(xxx) ((byte) ((word)(xxx) &amp; 255))</h1>

<h1>define WORD_HI(xxx) ((byte) ((word)(xxx) >> 8))</h1>

<p>```</p>

<p>11，返回一个比X大的最接近的8的倍数
```c</p>

<h1>define RND8( x ) ((((x) + 7) / 8 ) * 8 )</h1>

<p>```</p>

<p>12，将一个字母转换为大写
```c</p>

<h1>define UPCASE( c ) ( (&copy; >= &lsquo;a&rsquo; &amp;&amp; &copy; &lt;= &lsquo;z&rsquo;) ? (&copy; &ndash; 0x20) : &copy; )</h1>

<p>```</p>

<p>13，判断字符是不是10进值的数字
```c</p>

<h1>define DECCHK( c ) (&copy; >= &lsquo;0&rsquo; &amp;&amp; &copy; &lt;= &lsquo;9&rsquo;)</h1>

<p>```</p>

<p>14，判断字符是不是16进值的数字
```c</p>

<h1>define HEXCHK( c ) ( (&copy; >= &lsquo;0&rsquo; &amp;&amp; &copy; &lt;= &lsquo;9&rsquo;) ||\</h1>

<p>(&copy; >= &lsquo;A&rsquo; &amp;&amp; &copy; &lt;= &lsquo;F&rsquo;) ||\
(&copy; >= &lsquo;a&rsquo; &amp;&amp; &copy; &lt;= &lsquo;f&rsquo;) )
```</p>

<p>15，防止溢出的一个方法
```c</p>

<h1>define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val))</h1>

<p>```</p>

<p>16，返回数组元素的个数
```c</p>

<h1>define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</h1>

<p>```</p>

<p>17，返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2<sup>n</sup>)
```c</p>

<h1>define MOD_BY_POWER_OF_TWO( val, mod_by ) \</h1>

<p>( (dword)(val) &amp; (dword)((mod_by)-1) )
```</p>

<p>18，对于IO空间映射在存储空间的结构，输入输出处理
```c</p>

<h1>define inp(port) (<em>((volatile byte </em>) (port)))</h1>

<h1>define inpw(port) (<em>((volatile word </em>) (port)))</h1>

<h1>define inpdw(port) (<em>((volatile dword </em>)(port)))</h1>

<h1>define outp(port, val) (<em>((volatile byte </em>) (port)) = ((byte) (val)))</h1>

<h1>define outpw(port, val) (<em>((volatile word </em>) (port)) = ((word) (val)))</h1>

<h1>define outpdw(port, val) (<em>((volatile dword </em>) (port)) = ((dword) (val)))</h1>

<p>```</p>

<p>[2005-9-9添加]</p>

<p>19,使用一些宏跟踪调试</p>

<p>A N S I标准说明了五个预定义的宏名。它们是：</p>

<p>_ L I N E _</p>

<p>_ F I L E _</p>

<p>_ D A T E _</p>

<p>_ T I M E _</p>

<p>_ S T D C _</p>

<p>如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。记住编译程序</p>

<p>也许还提供其它预定义的宏名。</p>

<p>_ L I N E <em>及</em> F I L E _宏指令在有关# l i n e的部分中已讨论，这里讨论其余的宏名。</p>

<p>_ D AT E _宏指令含有形式为月/日/年的串，表示源文件被翻译到代码时的日期。</p>

<p>源代码翻译到目标代码的时间作为串包含在<em> T I M E </em>中。串形式为时：分：秒。</p>

<p>如果实现是标准的，则宏<em> S T D C </em>含有十进制常量1。如果它含有任何其它数，则实现是</p>

<p>非标准的。</p>

<p>可以定义宏，例如:</p>

<p>当定义了_DEBUG，输出数据信息和所在文件所在行
```c</p>

<h1>ifdef _DEBUG</h1>

<h1>define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,<em>LINE</em>,<em>FILE</em>)</h1>

<h1>else</h1>

<h1>define DEBUGMSG(msg,date)</h1>

<h1>endif</h1>

<p>```</p>

<p>20，宏定义防止使用是错误</p>

<p>用小括号包含。</p>

<p>例如：#define ADD(a,b) （a+b）</p>

<p>用do{}while(0)语句包含多语句防止错误</p>

<p>例如：#difne DO(a,b) a+b;\</p>

<p>a++;</p>

<p>应用时：if(….)</p>

<p>DO(a,b); //产生错误</p>

<p>else</p>

<p>解决方法: #difne DO(a,b) do{a+b;\</p>

<p>a++;}while(0)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[头文件中变量赋值方法]]></title>
    <link href="http://evoupsight.com/blog/2010/12/15/header-file-variable-assign/"/>
    <updated>2010-12-15T00:04:00+08:00</updated>
    <id>http://evoupsight.com/blog/2010/12/15/header-file-variable-assign</id>
    <content type="html"><![CDATA[<p>先看这段文字</p>

<!-- more -->




<hr>


<p>今天看C++ Primer关于头文件定义的一节，其中说到，头文件应用于声明而不是用于定义。其实，C++标准并没有规定头文件中不能定义 变量，只不过如果在头文件中定义变量，而该头文件又被多次包含的话，会造成变量的重新定义。
这里还涉及到另一个问题，需要提前说明，即使用预处理器避免多重包含。这里的多重包含指的是同一个文件直接或者间接的包含一个头文件多次，例如a.h包含 b.h，a.cpp同时包含a.h和b.h，a.cpp就两次包含了b.h。但由于b.h中具有避免多重包含的措施，a.cpp中还是只包含了b.h一 次。而包含的意思其实就是在预处理阶段用被包含文件的内容代替此包含语句。
回到头文件定义变量的问题上，如果在头文件中定义了变量，避免多重包含的措施只能避免该头文件在同一个编译单元内被包含一次，在不同的编译单元内还是会被多次包含的，这样就造成了变量的重复定义。
但是也有例外，如果const对象在编译时可以确定其值，可以将其放在头文件中定义。这么做是有原因的——const对象默认情况下是定义该变量的文件的 局部变量，这样即使此头文件被多个包含，都不会在包含这些文件中重复定义此变量，所有对于这个const对象的引用全都指向在头文件中定义的对象。如果在 const对象定义的时候声明extern，const对象就变得和普通非const对象一样，从而失去此特性（非const对象的默认属性为 extern）。
C++中的很多用法都不是标准C++规定的，但是由于各种原因，已经是约定俗成或是惯常用法，至于原因以及除此之外的其他用法完全可以不必深究，否则很容易钻牛角尖！</p>

<hr>


<p>今天移植gamedev里文章讲到的一个例子的时候碰到了这个问题，要在头文件里给一个变量定义。</p>

<p>最后这样就可以了
<code>c
//16Bit format for video card
const int PixelFormat = PF_555;
</code>
之前有些程序把一些库的变量定义都放到了主文件中，搞得非常难看，这下搞定了。
相应的在头文件里定义结构用typedef而不要去用struct！</p>
]]></content>
  </entry>
  
</feed>
