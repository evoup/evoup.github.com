<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cplusplus | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/cplusplus/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2013-11-12T11:39:55+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++实现crc32]]></title>
    <link href="http://evoupsight.com/blog/2010/11/26/crc32-cpp/"/>
    <updated>2010-11-26T19:07:00+08:00</updated>
    <id>http://evoupsight.com/blog/2010/11/26/crc32-cpp</id>
    <content type="html"><![CDATA[<p>直接参考如下连接
<a href="http://stackoverflow.com/questions/302914/crc32-c-or-c-implementation">http://stackoverflow.com/questions/302914/crc32-c-or-c-implementation</a></p>

<p>或者boost、Crypto++</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于头文件互相包含的解决方法]]></title>
    <link href="http://evoupsight.com/blog/2009/09/23/header-file-refered-by-each-other/"/>
    <updated>2009-09-23T23:09:00+08:00</updated>
    <id>http://evoupsight.com/blog/2009/09/23/header-file-refered-by-each-other</id>
    <content type="html"><![CDATA[<h2>写在前面，如果你这么写了，基本上不是很好的写法，以下是我的惨痛经验教训。</h2>

<p>我的游戏项目中有2个文件，其中cls_player.h包含cls_enemy.h,而且cls_enemy.h也要cls_player.h，这样子一来就成了重复包含了，虽然用防止重复包含头文件的宏#ifndef #define #endif，还是会报错。解决的方法初步看起来如下：</p>

<!-- more -->




<hr>


<p>不要在.h里互相包含头文件.</p>

<p>可以在另一个A的.h里声明一下class B,然后用B的指针就可以.包头文件放在A的cpp里包含就可以了.
</hr>
声明的时候只要在cls_enemy.h里面加上一句class class_player;就可以了。这样cls_enemy.h里就不要去包含cls_player.h了，而cls_player.h则照旧包含cls_enemy.h。但是在设计的时候发现还不行。</p>

<p>总结，如果2个类是差不多的类，最好放在一个文件里。</p>

<p>java倒是没有什么问题，所以java的话会这样子cls_player.java和cls_enemy.java
这样子大概会这么写
```java</p>

<h1>cls_player.java</h1>

<p>package com.evoup.player_enemy
import &hellip;
class cls_player{
   &hellip;
}
```</p>

<p>然后看搜到了这篇文章
<a href="http://topic.csdn.net/t/20051106/18/4375160.html">http://topic.csdn.net/t/20051106/18/4375160.html</a></p>

<p><a href="http://hi.baidu.com/030502505/blog/item/4a7eaba2e9cd12aacaefd06f.html/cmtid/11994e2a68a059315243c1b4">http://hi.baidu.com/030502505/blog/item/4a7eaba2e9cd12aacaefd06f.html/cmtid/11994e2a68a059315243c1b4</a></p>

<hr>


<h2>正解</h2>

<p>现在我总结一下问题的解决过程和方法：</p>

<p>方法一：利用友元类</p>

<p>我一共有两个类，由于要在两个类的头文件里互相应用对方，所以，在每一个类的头文件里面现包含另一个类的头文件，然后在该类的定义中声明另一个类为友元类。如下：
```c</p>

<h1>include &ldquo;B.h&rdquo;</h1>

<p>class CA: public CDialog
{</p>

<pre><code>friend class CB;
public:
CB* m_b; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>在另一个类中可以这样声明:
```c</p>

<h1>include &ldquo;A.h&rdquo;</h1>

<p>class CB: public CDialog
{</p>

<pre><code>friend class CA;
public:
CA * m_a; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>最后关键的是在每一个类的构造函数里 new 一个对方的类出来就ok了！</p>

<p>方法二：</p>

<p>我一共有两个类，由于要在两个类的头文件里互相应用对方，所以，在每一个类的头文件里面现包含另一个类的头文件，然后在该类的定义中声明另一个类为友元类。如下：
```c</p>

<h1>include &ldquo;B.h&rdquo;</h1>

<p>class CA: public CDialog
{</p>

<pre><code>friend class CB;
public:
CB* m_b; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>在另一个类中可以这样声明:
```c
class CA;
class CB: public CDialog
{</p>

<pre><code>public:
CA * m_a; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>在cb.cpp文件中包含头文件
```c</p>

<h1>include &ldquo;ca.h&rdquo;</h1>

<p>```</p>

<p>最后关键的是在每一个类的构造函数里 new 一个对方的类出来就ok了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初始化一组C++对象]]></title>
    <link href="http://evoupsight.com/blog/2009/06/10/cplusplus-init-a-lot-of-objects/"/>
    <updated>2009-06-10T13:29:00+08:00</updated>
    <id>http://evoupsight.com/blog/2009/06/10/cplusplus-init-a-lot-of-objects</id>
    <content type="html"><![CDATA[<p>今天要初始化一组对象</p>

<p><code>cpp
cls_enemy * enemy0[]={
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy()
};
</code></p>

<p>像这样初始化也太麻烦了吧，看看有什么对象链表之类的东西。</p>

<!-- more -->


<p>在VC里可以用CStringArray和CStringList或者CPtrArray或者CPtrList来做，那么STL里是一样的。正确做法可以是push_back的元素用new XX()做参数,但是效果好像也差不多，放在容器里看起来好像容易管理一些。
```cpp
vector&lt;cls_enemy*> ev;
for (i=0;i&lt;7;i++) {</p>

<pre><code>ev.push_back(new cls_enemy());
</code></pre>

<p>}
```</p>

<p>需要注意vector是模板类型，可以放任何类型，但是基于效率的考虑，最好放对象指针。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[STL中string到int的类型转换]]></title>
    <link href="http://evoupsight.com/blog/2009/06/02/cplusplus-string-to-int/"/>
    <updated>2009-06-02T14:04:00+08:00</updated>
    <id>http://evoupsight.com/blog/2009/06/02/cplusplus-string-to-int</id>
    <content type="html"><![CDATA[<p>STL的string转int的正确方法不是.data()
应该是
<code>cpp
aoti(obj.c_str());
</code></p>

<p>或者用个别人的string2int函数
<code>cpp
int string2int(const string &amp;s)
{
   int a;
   sscanf(s.c_str(), "%d", &amp;a);
   return a;
}
</code></p>

<p>然后int XX[];
完全可以用vector来实现</p>

<p><code>cpp
vector&lt;int &gt; v;
</code>
v[]一样可以的用的。</p>

<p>下面有个类似的
```cpp
int integer(string &amp;s)
{</p>

<pre><code>int a;
sscanf(s.c_str(), "%d", &amp;a);
return a;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
