<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cplusplus | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/cplusplus/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2014-07-10T15:44:09+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Evoup`s Blog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[freebsd上手动编译boost的boost-regex库]]></title>
    <link href="http://evoupsight.com/blog/2014/01/09/freebsd-install-boost-for-regex/"/>
    <updated>2014-01-09T14:45:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/01/09/freebsd-install-boost-for-regex</id>
    <content type="html"><![CDATA[<p>Boost这玩意用起来容易，安装起来却很麻烦，如果按照默认安装很庞大臃肿，原因是bjam搞得太复杂了。对于只使用其中某几个模块而采用整体安装的方式时间和空间上都是划不来的。如果只需要连接其中的正则表达式模块regex的话，可以采取单独安装的方法。</p>

<!-- more -->


<h3>1.生成bjam编译器</h3>

<p>boost不同的版本可能会有bjam包的路径不同的情况，这里采用boost_1_38_0为例。
<code>sh
$ pwd
/home/software
$ fetch http://sourceforge.net/projects/boost/files/boost/1.38.0/boost_1_38_0.tar.bz2
$ tar xjf boost_1_38_0.tar.bz2
$ cd tools/jam/src
$ ./build.sh
</code></p>

<p>编译后bjam程序存放于tools/jam/src/bin.freebsdx86_64/
<code>sh
vi ./tools/build/v2/user-config.jam
</code>
修改“#using gcc;”为"using gcc;"</p>

<h3>2.用bjam编译boost</h3>

<p><code>sh
$ ./bjam clean #清理之前的安装
$ ./bjam --build-type=complete --with-regex workdir #只编译regex库，生成include和lib
</code>
注意bjam编译时，需要注意bjam只是把boost的include和lib的路径放在本地，一个是当前目录的子目录boost中，一个是在刚在指定workdir的lib中。
然后复制到freebsd的include目录(/usr/local/include)和lib目录(/usr/local/lib)。
<code>sh
cd /home/software/boost_1_38_0
sudo cp -r boost /usr/local/include/
sudo cp -r workdir/lib /usr/local/
</code></p>

<h3>3.编译使用boost-regex的程序</h3>

<p>简单的程序regex.cpp试一把
```cpp</p>

<h1>include &lt;boost/regex.hpp></h1>

<h1>include <iostream></h1>

<p>int main() {</p>

<pre><code>std::string s = "&lt;html&gt;我是boost正则表达式匹配到的内容&lt;/html&gt;";
boost::regex reg( "&lt;html&gt;(.+?)&lt;/html&gt;" );
boost::sregex_token_iterator p( s.begin(), s.end(), reg, 01 );
boost::sregex_token_iterator end;
while ( p != end ) {
    std::cout &lt;&lt; *p++ &lt;&lt; std::endl;
}
return 1;
</code></pre>

<p>}
```
&mdash;&mdash;&mdash;&mdash;&mdash;-付测试方法&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<h3>编译方法</h3>

<p><code>sh
$ g++ -Wall regex.cpp -lboost_regex-gcc42-d-1_38 -I/usr/local/include -L/usr/local/lib -o regex
$ ./regex
我是boost正则表达式匹配到的内容
</code></p>

<p>这样就妥妥的了，祝各位看官好运，收工:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WIN7下安装VC++6.0的方法]]></title>
    <link href="http://evoupsight.com/blog/2014/01/08/win7-install-vc6/"/>
    <updated>2014-01-08T14:09:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/01/08/win7-install-vc6</id>
    <content type="html"><![CDATA[<p>今天打算研究snmp++的例子，要回来用一下vc6，WIN7上安装vc6还是会遇到一点点小问题，记录一下备查。</p>

<!-- more -->


<h3>步骤/方法</h3>

<p>1）在安装或使用Visual C++6.0时，如果出现兼容性问题提示对话框，都只要选择“不再显示此消息”，然后选择“运行程序”。根据网上资料和实践没有任何问题。</p>

<p>2）在安装Visual C++6.0过程中，选择“custom（自定义安装）”：其中visual source safe是不需安装的，这是微软的版本控制系统，咱就不装了。</p>

<p>3）最后最重要的一点，把windows7的UAC降到最低。然后打开vc6的时候需要以用管理员身份运行，这样就可以了。</p>

<h3>补充</h3>

<p>网上说还需要进到“工具”菜单的“选项”中，然后在“选项”窗口中选择“目录”选项卡。加入一些目录的路径。我实际试验下来可以不用这么做。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++实现crc32]]></title>
    <link href="http://evoupsight.com/blog/2010/11/26/crc32-cpp/"/>
    <updated>2010-11-26T19:07:00+08:00</updated>
    <id>http://evoupsight.com/blog/2010/11/26/crc32-cpp</id>
    <content type="html"><![CDATA[<p>直接参考如下连接
<a href="http://stackoverflow.com/questions/302914/crc32-c-or-c-implementation">http://stackoverflow.com/questions/302914/crc32-c-or-c-implementation</a></p>

<p>或者boost、Crypto++</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于头文件互相包含的解决方法]]></title>
    <link href="http://evoupsight.com/blog/2009/09/23/header-file-refered-by-each-other/"/>
    <updated>2009-09-23T23:09:00+08:00</updated>
    <id>http://evoupsight.com/blog/2009/09/23/header-file-refered-by-each-other</id>
    <content type="html"><![CDATA[<h2>写在前面，如果你这么写了，基本上不是很好的写法，以下是我的惨痛经验教训。</h2>

<p>我的游戏项目中有2个文件，其中cls_player.h包含cls_enemy.h,而且cls_enemy.h也要cls_player.h，这样子一来就成了重复包含了，虽然用防止重复包含头文件的宏#ifndef #define #endif，还是会报错。解决的方法初步看起来如下：</p>

<!-- more -->




<hr>


<p>不要在.h里互相包含头文件.</p>

<p>可以在另一个A的.h里声明一下class B,然后用B的指针就可以.包头文件放在A的cpp里包含就可以了.
</hr>
声明的时候只要在cls_enemy.h里面加上一句class class_player;就可以了。这样cls_enemy.h里就不要去包含cls_player.h了，而cls_player.h则照旧包含cls_enemy.h。但是在设计的时候发现还不行。</p>

<p>总结，如果2个类是差不多的类，最好放在一个文件里。</p>

<p>java倒是没有什么问题，所以java的话会这样子cls_player.java和cls_enemy.java
这样子大概会这么写
```java</p>

<h1>cls_player.java</h1>

<p>package com.evoup.player_enemy
import &hellip;
class cls_player{
   &hellip;
}
```</p>

<p>然后看搜到了这篇文章
<a href="http://topic.csdn.net/t/20051106/18/4375160.html">http://topic.csdn.net/t/20051106/18/4375160.html</a></p>

<p><a href="http://hi.baidu.com/030502505/blog/item/4a7eaba2e9cd12aacaefd06f.html/cmtid/11994e2a68a059315243c1b4">http://hi.baidu.com/030502505/blog/item/4a7eaba2e9cd12aacaefd06f.html/cmtid/11994e2a68a059315243c1b4</a></p>

<hr>


<h2>正解</h2>

<p>现在我总结一下问题的解决过程和方法：</p>

<p>方法一：利用友元类</p>

<p>我一共有两个类，由于要在两个类的头文件里互相应用对方，所以，在每一个类的头文件里面现包含另一个类的头文件，然后在该类的定义中声明另一个类为友元类。如下：
```c</p>

<h1>include &ldquo;B.h&rdquo;</h1>

<p>class CA: public CDialog
{</p>

<pre><code>friend class CB;
public:
CB* m_b; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>在另一个类中可以这样声明:
```c</p>

<h1>include &ldquo;A.h&rdquo;</h1>

<p>class CB: public CDialog
{</p>

<pre><code>friend class CA;
public:
CA * m_a; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>最后关键的是在每一个类的构造函数里 new 一个对方的类出来就ok了！</p>

<p>方法二：</p>

<p>我一共有两个类，由于要在两个类的头文件里互相应用对方，所以，在每一个类的头文件里面现包含另一个类的头文件，然后在该类的定义中声明另一个类为友元类。如下：
```c</p>

<h1>include &ldquo;B.h&rdquo;</h1>

<p>class CA: public CDialog
{</p>

<pre><code>friend class CB;
public:
CB* m_b; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>在另一个类中可以这样声明:
```c
class CA;
class CB: public CDialog
{</p>

<pre><code>public:
CA * m_a; //注意一定要是指针类型
</code></pre>

<p>}
```</p>

<p>在cb.cpp文件中包含头文件
```c</p>

<h1>include &ldquo;ca.h&rdquo;</h1>

<p>```</p>

<p>最后关键的是在每一个类的构造函数里 new 一个对方的类出来就ok了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初始化一组C++对象]]></title>
    <link href="http://evoupsight.com/blog/2009/06/10/cplusplus-init-a-lot-of-objects/"/>
    <updated>2009-06-10T13:29:00+08:00</updated>
    <id>http://evoupsight.com/blog/2009/06/10/cplusplus-init-a-lot-of-objects</id>
    <content type="html"><![CDATA[<p>今天要初始化一组对象</p>

<p><code>cpp
cls_enemy * enemy0[]={
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy(),
new cls_enemy()
};
</code></p>

<p>像这样初始化也太麻烦了吧，看看有什么对象链表之类的东西。</p>

<!-- more -->


<p>在VC里可以用CStringArray和CStringList或者CPtrArray或者CPtrList来做，那么STL里是一样的。正确做法可以是push_back的元素用new XX()做参数,但是效果好像也差不多，放在容器里看起来好像容易管理一些。
```cpp
vector&lt;cls_enemy*> ev;
for (i=0;i&lt;7;i++) {</p>

<pre><code>ev.push_back(new cls_enemy());
</code></pre>

<p>}
```</p>

<p>需要注意vector是模板类型，可以放任何类型，但是基于效率的考虑，最好放对象指针。</p>
]]></content>
  </entry>
  
</feed>
