<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nginx | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/nginx/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2016-08-03T14:48:06+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Evoup`s Blog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[配置nginx支持rrdcgi]]></title>
    <link href="http://evoupsight.com/blog/2013/10/25/nginx-with-rrdcgi/"/>
    <updated>2013-10-25T17:27:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/10/25/nginx-with-rrdcgi</id>
    <content type="html"><![CDATA[<p>开始在web界面上加载监控图表了，用rrdrool graph生成图，但是发现只能够生成。于是想当然地试了一下rrdcgi，本以为能够出图，结果还是创建图片，html来加载图片。最后发现ganglia的图表中居然也是先提取在临时目录生成好的图片，然后用php来生成头，最后再删除图片。不过顺便把nginx下配置CGI程序的知识学会了，权且记一笔。</p>

<!-- more -->

<h3 id="rrdcgi">RRDCGI的使用</h3>
<p>首先是编写graph.cgi</p>

<p><code>bash
#!/usr/local/bin/rrdcgi
 &lt;RRD::GRAPH
      /services/cgi-bin/load.png
      --imginfo '&lt;IMG SRC=/rrdgraph/%s WIDTH=%lu HEIGHT=%lu &gt;'
      --lazy --title="load"
      --start 1382666836 --end 1382677047
      --width 705 --height 245
      --alt-autoscale
          DEF:load=/services/rrds/yin-arch_ac101eb8/load.rrd:load:AVERAGE
          HRULE:1#ff0000:"warning value"
      AREA:load#3d3d3d:load&gt;
</code></p>

<p>语法基本和rrdgraph的差不多，没什么好说的，这样等等会生成出来一个html代码叫做</p>

<p><code>html
&lt;IMG SRC=/rrdgraph/load.png WIDTH=786 HEIGHT=324 &gt;
</code></p>

<p>首先在webroot下创建一个软连接rrdgraph，成的图片的src所指向rrdgraph文件夹，其实是个软连接，指向路径为/services/cgi-bin/
这么做是为了在nginx配置方便。</p>

<p>要怎么在shell中直接验证能出图呢？</p>

<p>```bash
sudo rrdcgi graph.cgi &lt; /dev/null
(offline mode: enter name=value pairs on standard input)
Content-Type: text/html
Content-Length: 53</p>

<p>&lt;IMG SRC=/rrdgraph/load.png WIDTH=786 HEIGHT=324 &gt;
```</p>

<p>很明显这样子是得到了load.png这个图片文件。然后把这个cgi文件移到/services/cgi-bin/目录下待机。</p>

<h3 id="nginxrrdcgi">nginx的对rrdcgi支持的配置</h3>
<p>首先需要安装好perl，还需要用到以下库：（以下版本可能过旧，直接到CPAN的网站搜索安装）</p>

<p>```bash
wget http://www.cpan.org/modules/by-module/FCGI/FCGI-0.67.tar.gz
tar -zxf FCGI-0.67.tar.gz
cd FCGI-0.67
perl Makefile.PL
make &amp;&amp; make install
cd ..</p>

<p>wget http://search.cpan.org/CPAN/authors/id/G/GB/GBJK/FCGI-ProcManager-0.18.tar.gz
tar -zxf FCGI-ProcManager-0.18.tar.gz
cd FCGI-ProcManager-0.18
perl Makefile.PL
make &amp;&amp; make install
cd ..</p>

<p>wget http://search.cpan.org/CPAN/authors/id/I/IN/INGY/IO-All-0.39.tar.gz
tar zxf IO-All-0.39.tar.gz
cd IO-All-0.39
perl Makefile.PL
make &amp;&amp; make install
```</p>

<p>安装 nginx-fcgi 脚本：</p>

<p>```bash
wget http://hily.me/blog/wp-content/uploads/2010/01/nginx-fcgi.txt</p>

<p>mv nginx-fcgi.txt /usr/sbin/nginx-fcgi</p>

<p>chmod +x /usr/sbin/nginx-fcgi
```</p>

<p>如果不用 sudo 方式运行 nginx-fcgi，请注释掉 nginx-fcgi 脚本中的：</p>

<p><code>bash
if ( $&gt; == “0″ ) {
print “\n\tERROR\tRunning as a root!\n”;
print “\tSuggested not to do so !!!\n\n”;
exit 1;
}
</code></p>

<p>启动 nginx-fcgi：</p>

<p><code>bash
sudo nginx-fcgi -l /var/log/nginx/nginx-fcgi.log -pid /var/run/nginx-fcgi.pid -S /var/run/nginx-fcgi.sock
</code></p>

<p>注意一定要为 socket 添加 nginx 帐户的权限，否则 cgi 会执行失败。
新建 nginx-fcgi 脚本指令配置，直接从 fastcgi_params 复制模板：</p>

<p><code>bash
cp /etc/nginx/fastcgi_params /etc/nginx/nginx_fcgi_params
</code></p>

<p>去除尾部的：</p>

<p><code>bash
# PHP only, required if PHP was built with –enable-force-cgi-redirect
fastcgi_param  REDIRECT_STATUS    200;
</code></p>

<p>最后的cgi站点配置：</p>

<p>```bash
        location / {
            root   /webroot;
            index  index.html index.htm;
        }</p>

<pre><code>    location ~ ^/cgi-bin/.*\.cgi$
    {
        fastcgi_index  index.cgi;
        fastcgi_param  SCRIPT_FILENAME    /services$fastcgi_script_name;
        include        nginx_fcgi_params;
        fastcgi_read_timeout    5m;
        fastcgi_pass   unix:/var/run/nginx-fcgi.sock;
    } ```
</code></pre>

<p>重启nginx，访问地址http://192.168.216.145/cgi-bin/graph.cgi</p>

<p>看到已经有图了
<img src="/images/evoup/rrdtool_load_graph2.png" alt="Alt text" /></p>

<h3 id="section">参考链接</h3>
<p>http://oss.oetiker.ch/rrdtool/doc/rrdcgi.en.html</p>

<p>http://wiki.qpsmtpd.org/doku.php?id=resources:statistics:rrdcgi-sample</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[freebsd下nginx+Php5.3.8+php-fpm源码安装之二]]></title>
    <link href="http://evoupsight.com/blog/2013/04/08/freebsd-nginx-php5-dot-3-8-plus-php-fpm-2/"/>
    <updated>2013-04-08T16:33:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/04/08/freebsd-nginx-php5-dot-3-8-plus-php-fpm-2</id>
    <content type="html"><![CDATA[<p>nginx端的配置
首先创建好web目录，假设在/services/www目录，在其下创建一个php测试脚本，php的脚本简单如下：</p>

<p><code>php
&lt;?php
phpinfo();
</code></p>

<p>安装nginx
安装简单的采用port，然后直接配置/usr/local/etc/nginx/nginx.conf</p>

<p>添加一个前缀test，我们访问http://192.168.216.198/test/index.php
或者
http://192.168.216.198/test/
即可看到php输出的信息。</p>

<p>默认nginx的fastcgi脚本似乎不直接支持php，需要创建一个文件php_fcgi_params.conf，然后在此文件中加入类似如下的代码：</p>

<p>```sh
#php_fcgi_params.conf                                                                                                                                            <br />
fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;                                                                                                                 <br />
fastcgi_param  SERVER_SOFTWARE    nginx;                                                                                                                   <br />
fastcgi_param  QUERY_STRING       $query_string;                                                                                                           <br />
fastcgi_param  REQUEST_METHOD     $request_method;                                                                                                         <br />
fastcgi_param  CONTENT_TYPE       $content_type;                                                                                                           <br />
fastcgi_param  CONTENT_LENGTH     $content_length;                                                                                                         <br />
fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;                                                                                      <br />
fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;                                                                                                    <br />
#fastcgi_param  SCRIPT_NAME        $request_uri;                                                                                                           <br />
fastcgi_param  PATH_INFO          $fastcgi_script_name;                                                                                                    <br />
fastcgi_param  REQUEST_URI        $request_uri;                                                                                                            <br />
fastcgi_param  DOCUMENT_URI       $document_uri;                                                                                                           <br />
fastcgi_param  DOCUMENT_ROOT      $document_root;                                                                                                          <br />
fastcgi_param  SERVER_PROTOCOL    $server_protocol;                                                                                                        <br />
fastcgi_param  REMOTE_ADDR        $remote_addr;                                                                                                            <br />
fastcgi_param  REMOTE_PORT        $remote_port;                                                                                                            <br />
fastcgi_param  SERVER_ADDR        $server_addr;                                                                                                            <br />
fastcgi_param  SERVER_PORT        $server_port;                                                                                                            <br />
fastcgi_param  SERVER_NAME        $server_name;                                                                                                            <br />
# PHP only, required if PHP was built with –enable-force-cgi-redirect                                                                                     <br />
fastcgi_param  REDIRECT_STATUS    200;</p>

<p>fastcgi_param       HTTP_X_REQUESTED_WITH       $http_x_requested_with;
```</p>

<p>在nginx.conf中的server上下文中添加</p>

<p><code>
        location ~ ^/pma/.*$ {
            #access_log /var/log/access_beta.log access1;
            index index.php index.html index.htm;
            root /services/www/;
            fastcgi_index   index.php;
            include /usr/local/etc/nginx/php_fcgi_params.conf;
            fastcgi_pass 127.0.0.1:9000;
        }
</code></p>

<p>启动nignx</p>

<p><code>sh
$ /usr/local/etc/rc.d/ngnix start
</code></p>

<p>访问浏览器http://192.168.216.198/pma/</p>

<p><img src="/images/evoup/php-fpm-pma.png" alt="Alt text" /></p>

<p>done!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[freebsd下nginx+Php5.3.8+php-fpm源码安装之一]]></title>
    <link href="http://evoupsight.com/blog/2013/04/08/freebsd-nginx-php5-dot-3-8-plus-php-fpm-1/"/>
    <updated>2013-04-08T01:03:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/04/08/freebsd-nginx-php5-dot-3-8-plus-php-fpm-1</id>
    <content type="html"><![CDATA[<p>本文在freebsd9.2 i386下进行。选择php5.3.8才能正常编译</p>

<h3 id="peclpeclphpext">pecl扩展(以下的pecl源码改名后放到php源码的ext目录下)</h3>
<p>i.memcache-3.0.4-&gt;memcache<br />
ii.APC-3.1.4-&gt;apc<br />
iii.imagick-3.0.0-&gt;imagick<br />
(已经把memcache,apc模块源码放到ext子目录中,名称如上)</p>

<p><code>sh
$ cd /your/phpsrcdir
$ rm configure
$ ./buildconf --force
$ ./configure --help   #(选项出现了!)
</code></p>

<h3 id="section">预装软件：</h3>
<p>ImageMagick</p>

<p><code>sh
$ make WITHOUT_X11=yes install clean
</code></p>

<p>(时间较长，干点别的去)
libevent(php-fpm需要,ports)</p>

<p><code>sh
$ make install clean
</code></p>

<p>curl(ports)</p>

<p><code>sh
$ make install clean
</code></p>

<p>libmcrypt(ports)</p>

<p><code>sh
make install clean
</code></p>

<h4 id="php533php-fpm">手动编译php,每个参数都要知道具体是干嘛的,5.3.3之后，有了php-fpm，</h4>
<p>–enable-fastcgi就不再需要了，mysqli以及pdo-mysql都用mysqlnd</p>

<p><code>sh
$'./configure' '--prefix=/usr/local/php5_admin' '--with-layout=GNU' '--with-config-file-scan-dir=/usr/local/php5_admin/etc/php' '--disable-all' '--enable-dom' '--enable-filter' '--enable-hash' '--enable-json' '--with-mcrypt' '--with-curl' '--with-pcre-regex' '--enable-mbstring' '--enable-ctype' '--enable-session' '--enable-libxml' '--enable-simplexml' '--enable-pdo' '--with-pdo-mysql=mysqlnd' '--with-mysqli=mysqlnd' '--with-mysql' '--enable-sysvsem' '--enable-sysvshm' '--enable-apc' '--enable-memcache' '--with-imagick=/usr/local' '--enable-fpm' --with-zlib --with-bz2 --enable-zip
</code></p>

<p>注意
make时候会报错
解决方法：
修改fpm_sockets.c代码：</p>

<p><code>
info.tcpi_sacked =&gt; info.__tcpi_sacked  
info.tcpi_unacked =&gt; info.__tcpi_unacked  
</code></p>

<h4 id="section-1">配置</h4>

<p><code>sh
$ cp /usr/local/php5_admin/etc/php-fpm.conf.default /usr/local/php5_admin/etc/php-fpm.conf
</code></p>

<p>几个需要配置的参数</p>

<p><code>sh
pm.max_children
pm.start_servers
pm.min_spare_servers
pm.max_spare_servers
</code></p>

<p>编辑启动脚本/usr/local/etc/rc.d/phpfpm</p>

<p><code>sh
#!/bin/sh
# PROVIDE: phpfpm
# REQUIRE: DAEMON
#
# Add the following lines to /etc/rc.conf to run phpfpm:
#
# phpfpm_enable (bool):   Set it to "YES" to enable {phpfpm}.
#               Default is "NO".
#
# Last-Modified: 2010-09-14 23:30:20
name="phpfpm" 
. /etc/rc.subr
rcvar=`set_rcvar`
load_rc_config ${name}
eval ${name}_enable=\${${name}_enable:-"NO"}
eval server=\${${name}_server:-"/usr/local/php5_admin/sbin/php-fpm"}
command=${server}
extra_commands="reload" 
sig_reload="USR2" 
pidfile="/usr/local/php5_admin/var/run/php-fpm.pid" 
#command_args="" 
run_rc_command "$1" 
</code>
   注意：启动脚本的权限555，还有/usr/local/php5_admin/var/run/php-fpm.pid可能需要手动创建</p>

<p>在/etc/rc.conf中加入</p>

<p><code>
phpfpm_enable="YES"
</code></p>

<p>然后启动</p>

<p><code>sh
$ /usr/local/etc/rc.d/phpfpm start
</code></p>

<p>备注，其实：上面的phpfpm配置文件是错误的，原因如下：
&gt; php 5.3.3以上的php版本源码中已经内嵌了php-fpm，不用象以前的php版本一样专门打补丁了，只需要在
configure的时候添加编译参数即可。
&gt; 但是，php 5.3.3以上版本的php-fpm 不再支持 php-fpm 以前具有的 /usr/local/php/sbin/php-fpm 
(start|stop|reload)等命令，需要使用信号控制：
&gt; master进程可以理解以下信号：
&gt; INT, TERM 立刻终止
&gt; QUIT 平滑终止
&gt; USR1 重新打开日志文件
&gt; USR2 平滑重载所有worker进程并重新载入配置和二进制模块</p>

<p>示例：
注意这边的单引号为“esc下面那个键（~）”
php-fpm 关闭：</p>

<p><code>sh
$ kill -INT `cat /usr/local/php/var/run/php-fpm.pid`
</code>
php-fpm 重启：</p>

<p><code>sh
$ kill -USR2 `cat /usr/local/php/var/run/php-fpm.pid`
</code></p>

<p>查看php-fpm进程：</p>

<p><code>sh
$ ps aux | grep -c php-fpm
</code></p>

<p>查看php-fpm进程数：</p>

<p><code>sh
$ ps aux | grep -c php-fpm | wc -l
</code></p>

<p>正确的脚本应该是这样的</p>

<p><code>sh
#!/bin/sh
# PROVIDE: phpfpm
# REQUIRE: DAEMON
#
# Add the following lines to /etc/rc.conf to run phpfpm:
#
# phpfpm_enable (bool):   Set it to "YES" to enable {phpfpm}.
#               Default is "NO".
#
# Last-Modified: 2012-11-22 10:27:43
name="phpfpm"
. /etc/rc.subr
rcvar=`set_rcvar`
load_rc_config ${name}
eval ${name}_enable=\${${name}_enable:-"NO"}
eval server=\${${name}_server:-"/usr/local/php5_admin/sbin/php-fpm"}
command=${server}
extra_commands="reload"
sig_reload="USR2"
sig_stop="INT"
pidfile="/usr/local/php5_admin/var/run/php-fpm.pid"
fpmconffile="/usr/local/php5_admin/etc/php-fpm.conf"
command_args="-g ${pidfile} -y ${fpmconffile}"
#run_rc_command $1
run_rc_command $*
</code></p>

<p>下篇讲nginx的配置</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx反向代理mongodb的web页面]]></title>
    <link href="http://evoupsight.com/blog/2013/01/05/nginx-reverse-proxy-mongodb/"/>
    <updated>2013-01-05T15:32:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/01/05/nginx-reverse-proxy-mongodb</id>
    <content type="html"><![CDATA[<p>需要配置nginx来反向代理出mongodb的web页面，参考这篇文章
<!-- more -->
http://serverfault.com/questions/418212/nginx-reverse-proxy-to-mongodb-rest-interface</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>nginx配置文件 </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>…
</span><span class='line'>location / <span class="o">{</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;   access_log /var/log/access.log access1;
</span><span class='line'>
</span><span class='line'>   proxy_redirect     off;
</span><span class='line'>
</span><span class='line'>   proxy_connect_timeout      90;
</span><span class='line'>
</span><span class='line'>   proxy_send_timeout         90;
</span><span class='line'>
</span><span class='line'>   proxy_read_timeout         90;
</span><span class='line'>
</span><span class='line'>   proxy_buffer_size          4k;
</span><span class='line'>
</span><span class='line'>   proxy_buffers              432k;
</span><span class='line'>
</span><span class='line'>   proxy_busy_buffers_size    64k;
</span><span class='line'>
</span><span class='line'>   proxy_temp_file_write_size 64k;
</span><span class='line'>
</span><span class='line'>   add_header Cache-Control no-cache;
</span><span class='line'>
</span><span class='line'>   proxy_pass http://172.16.30.184:28017;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="o">}</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="o">}</span>
</span><span class='line'>…
</span></code></pre></td></tr></table></div></figure></notextile></div>
不足：只能从根目录进行代理,如需更加完善，需要装编译nginx的时候， –with-http_stub_status_module</p>

<p>然后参考《nginx反代加替换傻瓜教程》进行配置</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决nginx upstream send too big header]]></title>
    <link href="http://evoupsight.com/blog/2012/11/22/nginx-upstream-send-too-big-header/"/>
    <updated>2012-11-22T15:01:00+08:00</updated>
    <id>http://evoupsight.com/blog/2012/11/22/nginx-upstream-send-too-big-header</id>
    <content type="html"><![CDATA[<p>遭遇nginx upstream sent too big header while reading response header from upstream</p>

<p>这个问题会导致输出502头信息。</p>

<p>在fastcgi_params中加以下2行</p>

<p><code>sh
fastcgi_buffer_size 128k;
fastcgi_buffers 8 128k;
</code></p>

<p>原因是nginx处理header太大了，还有一个原因就是我写程序的时候发header太多了，只能发一次，调试的时候再去做了。</p>
]]></content>
  </entry>
  
</feed>
