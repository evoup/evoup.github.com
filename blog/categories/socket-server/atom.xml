<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: socket server | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/socket-server/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2016-11-21T18:48:33+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Evoup`s Blog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于socket阻塞与非阻塞情况下的recv、send、read、write返回值]]></title>
    <link href="http://evoupsight.com/blog/2013/01/09/socket-server-recv-send-read-write-with-block-and-unblock/"/>
    <updated>2013-01-09T11:42:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/01/09/socket-server-recv-send-read-write-with-block-and-unblock</id>
    <content type="html"><![CDATA[<h4 id="recv">recv：</h4>

<p>阻塞与非阻塞recv返回值没有区分，都是 &lt;0：出错，=0：连接关闭，&gt;0接收到数据大小，</p>

<table>
  <tbody>
    <tr>
      <td>特别：非阻塞模式下返回 值 &lt;0时并且(errno == EINTR</td>
      <td> </td>
      <td>errno == EWOULDBLOCK</td>
      <td> </td>
      <td>errno == EAGAIN)的情况 下认为连接是正常的，继续接收。</td>
    </tr>
  </tbody>
</table>

<!--more -->

<p>只是阻塞模式下recv会阻塞着接收数据，非阻塞模式下如果没有数据会返回，不会阻塞着读，因此需要 循环读取。</p>

<h4 id="write">write：</h4>

<p>阻塞与非阻塞write返回值没有区分，都是 &lt;0：出错，=0：连接关闭，&gt;0发送数据大小，</p>

<table>
  <tbody>
    <tr>
      <td>特别：非阻塞模式下返回值 &lt;0时并且 (errno == EINTR</td>
      <td> </td>
      <td>errno == EWOULDBLOCK</td>
      <td> </td>
      <td>errno == EAGAIN)的情况下认为连接是正常的， 继续发送。</td>
    </tr>
  </tbody>
</table>

<p>只是阻塞模式下write会阻塞着发送数据，非阻塞模式下如果暂时无法发送数据会返回，不会阻塞着 write，因此需要循环发送。</p>

<h4 id="read">read：</h4>

<p>阻塞与非阻塞read返回值没有区分，都是 &lt;0：出错，=0：连接关闭，&gt;0接收到数据大小，</p>

<table>
  <tbody>
    <tr>
      <td>特别：非阻塞模式下返回 值 &lt;0时并且(errno == EINTR</td>
      <td> </td>
      <td>errno == EWOULDBLOCK</td>
      <td> </td>
      <td>errno == EAGAIN)的情况 下认为连接是正常的，继续接收。</td>
    </tr>
  </tbody>
</table>

<p>只是阻塞模式下read会阻塞着接收数据，非阻塞模式下如果没有数据会返回，不会阻塞着读，因此需要 循环读取。</p>

<h4 id="send">send：</h4>

<p>阻塞与非阻塞send返回值没有区分，都是 &lt;0：出错，=0：连接关闭，&gt;0发送数据大小，</p>

<table>
  <tbody>
    <tr>
      <td>特别：非阻塞模式下返回值 &lt;0时并且 (errno == EINTR</td>
      <td> </td>
      <td>errno == EWOULDBLOCK</td>
      <td> </td>
      <td>errno == EAGAIN)的情况下认为连接是正常的， 继续发送。</td>
    </tr>
  </tbody>
</table>

<p>只是阻塞模式下send会阻塞着发送数据，非阻塞模式下如果暂时无法发送数据会返回，不会阻塞着 send，因此需要循环发送。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[服务器开发知识汇总2010年整理的]]></title>
    <link href="http://evoupsight.com/blog/2012/01/09/server-develop-knowledge/"/>
    <updated>2012-01-09T16:41:00+08:00</updated>
    <id>http://evoupsight.com/blog/2012/01/09/server-develop-knowledge</id>
    <content type="html"><![CDATA[<p>整理了一些服务开发的文章，以备不时之需</p>

<p><a href="http://www.raosoft.com/help/cgi/ezs/index.html">一个开源CGI程序</a></p>

<p><a href="http://www.cnblogs.com/sld666666/archive/2010/06/27/1766255.html">nginx内存池用法(分析得不透，没有说出父子内存池，也搞错了子内存池其实是放一个指针到父内存池)</a></p>

<!-- more -->

<p><a href="nginx中的output">http://simohayha.javaeye.com/blog/651779</a></p>

<p><a href="nginx的内存管理">http://simohayha.javaeye.com/blog/545192</a></p>

<p><a href="http://www.cnblogs.com/sld666666/archive/2010/06/20/1761457.html">typedef和函数指针</a>  （nginx实现，自己实现过一个）</p>

<p><a href="http://blog.csdn.net/telehiker/archive/2007/10/18/1830575.aspx">syslog用法，只要看/var/log/debug的信息就可以了。《Linux下syslog日志函数使用》</a></p>

<p><a href="http://www.boluor.com/linux-cs-ipc-using-named-pipe.html">如何改进winsocks版的police server,(参考一goto)</a></p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-makefile/">autoconf和automake来生成Makefile</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2007/07/27/1711369.aspx">通用链表（封装得很烂，试过一把）</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2007/07/02/1675740.aspx">线程里处理信号</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/01/16/2047701.aspx">HTTP协议中的Tranfer-Encoding：chunked编码解析</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2007/10/05/1812419.aspx">php正则表达参考(转的时候要知道)</a></p>

<p><a href="http://deerchao.net/tutorials/regex/regex.htm">结合这篇一起看</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/09/15/2932630.aspx">线程里sleep的正确的方法（用在定时做服务器广播的那个线程）</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/09/02/2869097.aspx">socket封包和拆包</a></p>

<p><a href="http://hi.baidu.com/infant/blog/item/4439b2fb5ef67e284e4aeac8.html">offsetof和POD</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2010/07/09/5722669.aspx">memcache测试</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/11/19/3333617.aspx">fork两次如何避免僵尸进程</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/12/11/3497556.aspx">glib库hash表GHashTable介绍(也抄了一个snort的实现，这个是内置的选择)</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/12/30/3645552.aspx">Linux动态库(.so)搜索路径(编译时候确认)</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/12/19/3560366.aspx">惊群（不要试图把accept加锁,最好连锁都不用）</a></p>

<p><a href="http://www.xfocus.net/tools/12.html">攻击工具(h00lyshit.c)</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2008/11/17/3322023.aspx">netstat全部参数</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2009/03/29/4033722.aspx">GDB调试</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2009/11/17/4819444.aspx">使用setsockopt来控制connect超时</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2009/10/26/4727644.aspx">八大排序算法总结</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2010/08/11/5804244.aspx">atoi源码(做地图的时候用的到)</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2010/06/02/5642550.aspx">异步下socket的返回值</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2010/08/23/5832481.aspx">C++的curl库调用手册</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2009/04/15/4075611.aspx">qsort和bsearch（qsort是快速排序，bsearch是二分查找）</a></p>

<hr />
<p>协议
<a href="http://blog.csdn.net/eroswang/archive/2010/11/16/6011566.aspx">protobuffer(号称比json好)</a></p>

<hr />
<p>调试
<a href="http://blog.csdn.net/eroswang/archive/2009/11/09/4791875.aspx">显示16进制数据(vim和hexdump)</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2010/11/03/5983791.aspx">GCC内部都做些什么</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2009/07/28/4388837.aspx">杀掉僵尸进程</a></p>

<hr />
<p>内核等级
<a href="http://blog.csdn.net/eroswang/archive/2009/04/24/4107322.aspx">IOSTAT</a></p>

<p><a href="http://blog.csdn.net/eroswang/archive/2009/04/27/4130972.aspx">malloc OS等级分析</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[socket服务器开发心得[长连接线程版]]]></title>
    <link href="http://evoupsight.com/blog/2010/11/05/socket-server-experience/"/>
    <updated>2010-11-05T11:23:00+08:00</updated>
    <id>http://evoupsight.com/blog/2010/11/05/socket-server-experience</id>
    <content type="html"><![CDATA[<p>其实也算不上是什么心得，就是一些积累。cs结构的网游和聊天室基本上是在用长连接。</p>

<p>长连接一般会有个心跳包，具体就是确认客户端状态是存活的，这个还没有设计。</p>

<p>QQ其实也用TCP，也有心跳包，也涉及长连接。</p>

<p>P2P一般都是长连接，但是网游一般不设计成UDP数据包，一般都是长连接。</p>

<p>对于多线程阻塞服务器，recv就可以了，然后开个for(;;)或者while(1)死循环，长连接式的recv和send，这样交互，中间使用\n或者其他什么判断接受的一条协议命令；对于http这样的服务器，直接fopen套接字，fstat判断可写状态，则写入后fflush。这个flash也用了个flush函数，具体怎么回事，没做深入研究。</p>
]]></content>
  </entry>
  
</feed>
