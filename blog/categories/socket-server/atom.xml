<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: socket server | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/socket-server/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2014-01-09T15:42:47+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于socket阻塞与非阻塞情况下的recv、send、read、write返回值]]></title>
    <link href="http://evoupsight.com/blog/2013/01/09/socket-server-recv-send-read-write-with-block-and-unblock/"/>
    <updated>2013-01-09T11:42:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/01/09/socket-server-recv-send-read-write-with-block-and-unblock</id>
    <content type="html"><![CDATA[<h4>recv：</h4>

<p>阻塞与非阻塞recv返回值没有区分，都是 &lt;0：出错，=0：连接关闭，>0接收到数据大小，</p>

<p>特别：非阻塞模式下返回 值 &lt;0时并且(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况 下认为连接是正常的，继续接收。</p>

<!--more -->


<p>只是阻塞模式下recv会阻塞着接收数据，非阻塞模式下如果没有数据会返回，不会阻塞着读，因此需要 循环读取。</p>

<h4>write：</h4>

<p>阻塞与非阻塞write返回值没有区分，都是 &lt;0：出错，=0：连接关闭，>0发送数据大小，</p>

<p>特别：非阻塞模式下返回值 &lt;0时并且 (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况下认为连接是正常的， 继续发送。</p>

<p>只是阻塞模式下write会阻塞着发送数据，非阻塞模式下如果暂时无法发送数据会返回，不会阻塞着 write，因此需要循环发送。</p>

<h4>read：</h4>

<p>阻塞与非阻塞read返回值没有区分，都是 &lt;0：出错，=0：连接关闭，>0接收到数据大小，</p>

<p>特别：非阻塞模式下返回 值 &lt;0时并且(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况 下认为连接是正常的，继续接收。</p>

<p>只是阻塞模式下read会阻塞着接收数据，非阻塞模式下如果没有数据会返回，不会阻塞着读，因此需要 循环读取。</p>

<h4>send：</h4>

<p>阻塞与非阻塞send返回值没有区分，都是 &lt;0：出错，=0：连接关闭，>0发送数据大小，</p>

<p>特别：非阻塞模式下返回值 &lt;0时并且 (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况下认为连接是正常的， 继续发送。</p>

<p>只是阻塞模式下send会阻塞着发送数据，非阻塞模式下如果暂时无法发送数据会返回，不会阻塞着 send，因此需要循环发送。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[socket服务器开发心得[长连接线程版]]]></title>
    <link href="http://evoupsight.com/blog/2010/11/05/socket-server-experience/"/>
    <updated>2010-11-05T11:23:00+08:00</updated>
    <id>http://evoupsight.com/blog/2010/11/05/socket-server-experience</id>
    <content type="html"><![CDATA[<p>其实也算不上是什么心得，就是一些积累。cs结构的网游和聊天室基本上是在用长连接。</p>

<p>长连接一般会有个心跳包，具体就是确认客户端状态是存活的，这个还没有设计。</p>

<p>QQ其实也用TCP，也有心跳包，也涉及长连接。</p>

<p>P2P一般都是长连接，但是网游一般不设计成UDP数据包，一般都是长连接。</p>

<p>对于多线程阻塞服务器，recv就可以了，然后开个for(;;)或者while(1)死循环，长连接式的recv和send，这样交互，中间使用\n或者其他什么判断接受的一条协议命令；对于http这样的服务器，直接fopen套接字，fstat判断可写状态，则写入后fflush。这个flash也用了个flush函数，具体怎么回事，没做深入研究。</p>
]]></content>
  </entry>
  
</feed>
