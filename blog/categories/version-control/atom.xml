<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: version_control | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/version-control/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2016-08-03T16:44:09+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Evoup`s Blog]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[同步github分支过来的代码库]]></title>
    <link href="http://evoupsight.com/blog/2015/04/21/sync-fork-github/"/>
    <updated>2015-04-21T13:53:00+08:00</updated>
    <id>http://evoupsight.com/blog/2015/04/21/sync-fork-github</id>
    <content type="html"><![CDATA[<p>主要的步骤是先查看当前fork的远程代码库
<!-- more -->
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git remote -v
</span><span class='line'>origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git <span class="o">(</span>fetch<span class="o">)</span>
</span><span class='line'>origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git <span class="o">(</span>push<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>然后添加一个上游代码库，地址就是之前被fork的那个代码库
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>再次查看
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git remote -v
</span><span class='line'>origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git <span class="o">(</span>fetch<span class="o">)</span>
</span><span class='line'>origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git <span class="o">(</span>push<span class="o">)</span>
</span><span class='line'>upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git <span class="o">(</span>fetch<span class="o">)</span>
</span><span class='line'>upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git <span class="o">(</span>push<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>接着用如下命令获取上游代码并合并到当前工作区
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git fetch upstream
</span><span class='line'>git checkout master
</span><span class='line'>git merge upstream/master
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>最后git push origin master即可完成提交。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git分支学习]]></title>
    <link href="http://evoupsight.com/blog/2014/05/10/git-branch-learning/"/>
    <updated>2014-05-10T14:17:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/05/10/git-branch-learning</id>
    <content type="html"><![CDATA[<p>主要学习的内容：git默认分支是什么，如何创建分支，如何查看所有分支，如何查看当前分支，如何提交分支，如何切换到分支,以下简单给出答案：
<!-- more --></p>

<p>git的默认分支是master</p>

<p>创建分支</p>

<p><code>bash
git branch branchname 
</code></p>

<p>显示所有分支</p>

<p><code>bash
git show-branch
</code></p>

<p>查看当前分支</p>

<p><code>bash
git status
</code></p>

<p>提交分支</p>

<p><code>bash
git push origin branchname
</code></p>

<p>切换到名字为branchname的分支</p>

<p><code>bash
git checkout branchname
</code></p>

<p>创建一个分支，然后把这个分支同步到远程仓库</p>

<p><code>bash
git branch branchname
git checkout branchname
git push origin branchname
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git clone失败警告unprotected private key file]]></title>
    <link href="http://evoupsight.com/blog/2014/01/16/git-clone-fail-cause-unprotected-private-key-file/"/>
    <updated>2014-01-16T23:41:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/01/16/git-clone-fail-cause-unprotected-private-key-file</id>
    <content type="html"><![CDATA[<h3 id="section">起因</h3>
<p>今天在clone项目的时候发生了很奇怪的错误，而且居然是有的项目可以clone，有的不行，都是git协议。错误如下：</p>

<!-- more -->

<p>```sh
$ git clone git@github.com:someone/case.git
Cloning into ‘case’…
Warning: Permanently added the RSA host key for IP address ‘192.30.252.129’ to t
he list of known hosts.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions 0644 for ‘/c/Users/Administrator/.ssh/id_rsa’ are too open.
It is recommended that your private key files are NOT accessible by others.
This private key will be ignored.
bad permissions: ignore key: /c/Users/Administrator/.ssh/id_rsa
Permission denied (publickey).
fatal: Could not read from remote repository.</p>

<p>Please make sure you have the correct access rights
and the repository exists.
```
###排查
显示是私钥权限不正确导致的，然后定位到git-bash所使用的sh.exe程序，用管理员模式运行</p>

<p><code>bash
chmod 0600 /c/Users/Administrator/.ssh/id_rsa
</code></p>

<p>尝试几次都没法收回group和other的r权限（r+w+rw=2^2+2^1+2^0，我这里是4，2^2所以是r）
最后发现是因为装git windows的时候选择了第一种方式和cygwin正好冲突了，如果装了cygwin的基础上再安装git windows要在git windows的安装选项里选第二种方式；还有一种可能是和tortoise git冲突了，尚未确认。
最后删除cygwin重装git-bash可以正常clone了。</p>

<h3 id="section-1">延伸</h3>
<p>git windows还有第三种安装方式，第三种比较危险，会覆盖windows指令，一般不采取，如果以后不打算用cygwin的话，直接第一种方式安装就可以了。</p>

<p>附：正常的权限掩码，来自一台freebsd</p>

<p><code>bash
-rw-r--r--   authorized_keys
-rw-------   config
-rw-------   id_dsa
-rw-------   id_dsa.pub
-rw-------   id_rsa
-rw-r--r--   id_rsa.pub
-rw-------   known_hosts
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git免密码使用https协议]]></title>
    <link href="http://evoupsight.com/blog/2013/12/30/git-use-https-protocol/"/>
    <updated>2013-12-30T22:09:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/12/30/git-use-https-protocol</id>
    <content type="html"><![CDATA[<p>git支持的协议主要有git、ssh、http、https这几种，国内防火墙对github的作用下，导致长期使用github服务的程序开发人员要忍受缓慢的push和pull速度。现在终于找到了一个比较不错的方法提升工作效率，那就是使用goagent+git/https的方式。
<!-- more --></p>

<p>goagent配置这里就不提了，主要给出git端的设置参考,假设是在bash终端下操作git，需要设置这2个环境变量，写到~/.bashrc中再source一下即可</p>

<p><code>bash
export https_proxy="127.0.0.1:8087"
export http_proxy="127.0.0.1:8087"
</code></p>

<p>其实这里是通过linux的http/https代理设置的方法来加速！
如果是tcsh</p>

<p><code>bash
setenv https_proxy "127.0.0.1:8087"
setenv http_proxy "127.0.0.1:8087"
</code></p>

<p>同样是把以上的代码加到~/.cshrc中再source一下</p>

<p>速度的问题解决了之后，你会发现其实每次都非常讨厌输入用户名和密码，那请看下文</p>

<p>执行</p>

<p><code>bash
touch $HOME/.git-credentials
</code></p>

<p>编辑$HOME/.get-credentials
加入</p>

<p><code>bash
https://username:password@github.com
</code></p>

<p>其中username和password分别为你的git用户名和密码</p>

<p>再执行</p>

<p><code>bash
git config --global credential.helper store
</code></p>

<p>这样git push就不需要输入密码了，享受成就感吧</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[centos下CVS服务器的配置]]></title>
    <link href="http://evoupsight.com/blog/2013/11/08/centos-install-cvs/"/>
    <updated>2013-11-08T13:20:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/11/08/centos-install-cvs</id>
    <content type="html"><![CDATA[<p>由于需要回顾以前在自己的cvs上建设的一些项目,把其中有用的项目直接放到github上方便调用，现在需要重拾cvs这个历史悠久的版本管理工具了。</p>

<!-- more -->

<p>在centos6上建设cvs服务器是比较方便的。大体分为几个步骤，xinetd-&gt;cvs-&gt;配置帐号-&gt;配置xinetd下pcvsserver文件-&gt;启动cvs服务端</p>

<h4 id="xinetd">1.安装xinetd</h4>

<p><code>bash
rpm -q xinetd 
</code></p>

<p>没有安装的话</p>

<p><code>bash 
yum install xinetd
</code></p>

<h4 id="cvs">2.安装cvs</h4>

<p><code>bash
rpm -q cvs
</code></p>

<p>我的系统显示
cvs-1.11.23-15.el6.x86_64
如果没有安装的话可以</p>

<p><code>bash
yum install cvs
</code></p>

<h4 id="section">3.配置帐号</h4>
<p>切换到root，执行：</p>

<p><code>bash
groupadd cvs
useradd -g cvs cvsroot
passwd cvsroot
</code></p>

<p>这样帐号就配置好了。</p>

<h4 id="cvsetcxinetddpcvsserver">4.修改cvs的配置文件/etc/xinetd.d/pcvsserver</h4>

<p><code>bash
# default: off
# description: The CVS service can record the history of your source \
#              files. CVS stores all the versions of a file in a single \
#              file in a clever way that only stores the differences \
#              between versions.
service cvspserver
{
        disable                 = no
        port                    = 2401
        socket_type             = stream
        protocol                = tcp
        wait                    = no
        user                    = root
        passenv                 = PATH
        server                  = /usr/bin/cvs
        env                     = HOME=/home/cvsroot
        server_args             = -f --allow-root=/home/cvsroot pserver
#       bind                    = 127.0.0.1
}
</code>
其中env为cvs的环境变量地址，server_args指定你项目的源代码的保存路径和认证方式，这里pserver为基于密码的认证方式。</p>

<h4 id="section-1">5.初始化和启动</h4>
<p>初始化项目仓库的命令为</p>

<p><code>bash
cvs -d /home/cvsroot init
</code></p>

<p>就是在刚才配置的env = HOME=/home/cvsroot目录长噢乖创建代码仓库</p>

<p>接下来重启xinetd</p>

<p><code>bash
/etc/rc.d/init.d/xinetd restart
</code></p>

<p>测试cvs是否存在
lsof -p 2401
或者
netstat -l | grep csv
不能使用ps aux | grep cvs，因为这是在xinetd下！</p>

<p>安装就完成了。</p>

<p>接下来还要提一下客户端tortoise cvs使用的问题，需要把cvs.exe的路径加到环境变量PATH中方可使用或者把cvsnt这款软件的cvs.exe拷贝到tortoise cvs安装目录中，否则会报句柄错误。</p>

<h4 id="section-2">参考链接：</h4>

<p>http://blog.csdn.net/lidongtang/article/details/8165574</p>

]]></content>
  </entry>
  
</feed>
