<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2014-01-22T10:56:39+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Win7上Android模拟器上安装apk软件]]></title>
    <link href="http://evoupsight.com/blog/2014/01/20/win7-install-apk-on-android-emulator/"/>
    <updated>2014-01-20T14:56:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/01/20/win7-install-apk-on-android-emulator</id>
    <content type="html"><![CDATA[<h3>前提</h3>

<p>在android模拟器上安装apk文件（android安装包）很简单,要求2个前提：</p>

<pre><code>    1）已经安装好了ADK（android sdk）

    2）配置好virtual device
</code></pre>

<!-- more -->


<h3>准备工作</h3>

<p>假设您已经安装好了ADK，运行Eclipse选择Window菜单：</p>

<p><img src="/images/evoup/android_emulator_install_apk_first.png" alt="Alt text" /></p>

<p>选择下方的Android Virtual Device Manager->new,我们创建一个android2.2的通用虚拟设备，屏幕选最小的我这里方便截图（一般会选择3.7WVGA,后期根据自己的需要可以做任意选择），然后取名这个模拟器为testAVD。</p>

<p><img src="/images/evoup/android_emulator_create_new_one.png" alt="Alt text" /></p>

<p>点击OK完成，然后选择testAVD并Start启动模拟器，然后选择launch。第一次启动很慢，至于到底需要多少时间取决于机器的性能。</p>

<p><img src="/images/evoup/android_emulator_starting.png" alt="Alt text" /></p>

<p>这样就算进去了</p>

<p><img src="/images/evoup/android_emulator_entered.png" alt="Alt text" /></p>

<h3>安装apk</h3>

<p>进入ADK的platform_tools目录下，运行<code>adb install apk文件</code>就可以完成安装。</p>

<p>以安装微信安卓版本为例，假设我下载到了C:\weixin510android360.apk</p>

<p><img src="/images/evoup/android_emulator_entered.png" alt="Alt text" /></p>

<p>我这里比较慢，可能是因为选择的模拟器内存参数没有调大导致的。</p>

<p><img src="/images/evoup/android_emulator_install_apk.png" alt="Alt text" /></p>

<p>等待安装完成吧</p>

<p><img src="/images/evoup/android_emulator_install_apk_done.png" alt="Alt text" /></p>

<p><img src="/images/evoup/android_emulator_install_apk_done2.png" alt="Alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android webview helloworld分析]]></title>
    <link href="http://evoupsight.com/blog/2014/01/19/android-webview-helloworld/"/>
    <updated>2014-01-19T17:05:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/01/19/android-webview-helloworld</id>
    <content type="html"><![CDATA[<h3>加载示例代码</h3>

<p>官方示例代码
<a href="https://code.google.com/p/apps-for-android/source/browse/#git%2FSamples%2FWebViewDemo">https://code.google.com/p/apps-for-android/source/browse/#git%2FSamples%2FWebViewDemo</a></p>

<p>运行Eclipse(本文提到的eclipse版本是Eclipse ide for java developer KEPLER)，选择File->Import&hellip;&ndash;>Android->Existing Android Code Into Workspace,Next，在Root Directory中选择解压的目录下的Samples文件夹下的WebViewDemo。</p>

<p>如果直接run，会出现错误<code>Project has no project.properties file! Edit the project properties to set one.</code>。
这时只要右键项目属性properties &ndash;> android &ndash;> Project Build Target 把里面的Androidx.x改为对应的google APIs版本。google APIs是android apis的超集，Android只是其中一个用于移动设备的OS，可以有限的调用一些google api。</p>

<h3>分析app部分代码</h3>

<p>请看示例java代码</p>

<!-- more -->


<p>{% codeblock lang:java WebViewDemo.java %}
package com.google.android.webviewdemo;</p>

<p>import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.webkit.JsResult;
import android.webkit.WebChromeClient;
import android.webkit.WebSettings;
import android.webkit.WebView;</p>

<p>/<em>*
 * Demonstrates how to embed a WebView in your activity. Also demonstrates how
 * to have javascript in the WebView call into the activity, and how the activity
 * can invoke javascript.
 * <p>
 * In this example, clicking on the android in the WebView will result in a call into
 * the activities code in {@link DemoJavaScriptInterface#clickOnAndroid()}. This code
 * will turn around and invoke javascript using the {@link WebView#loadUrl(String)}
 * method.
 * <p>
 * Obviously all of this could have been accomplished without calling into the activity
 * and then back into javascript, but this code is intended to show how to set up the
 * code paths for this sort of communication.
 *
 </em>/
public class WebViewDemo extends Activity {</p>

<pre><code>private static final String LOG_TAG = "WebViewDemo";

private WebView mWebView;

private Handler mHandler = new Handler();

@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    setContentView(R.layout.main);
    mWebView = (WebView) findViewById(R.id.webview);

    WebSettings webSettings = mWebView.getSettings();
    webSettings.setSavePassword(false);
    webSettings.setSaveFormData(false);
    webSettings.setJavaScriptEnabled(true);
    webSettings.setSupportZoom(false);

    mWebView.setWebChromeClient(new MyWebChromeClient());

    mWebView.addJavascriptInterface(new DemoJavaScriptInterface(), "demo");

    mWebView.loadUrl("file:///android_asset/demo.html");
}

final class DemoJavaScriptInterface {

    DemoJavaScriptInterface() {
    }

    /**
     * This is not called on the UI thread. Post a runnable to invoke
     * loadUrl on the UI thread.
     */
    public void clickOnAndroid() {
        mHandler.post(new Runnable() {
            public void run() {
                mWebView.loadUrl("javascript:wave()");
            }
        });

    }
}

/**
 * Provides a hook for calling "alert" from javascript. Useful for
 * debugging your javascript.
 */
final class MyWebChromeClient extends WebChromeClient {
    @Override
    public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
        Log.d(LOG_TAG, message);
        result.confirm();
        return true;
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>首先需要搞懂Activity这个核心概念，基本上是进行android的活动对象事件调度的类，我们看一下android api中的activity的生命周期：</p>

<p><img src="/images/evoup/activity_lifecycle.png" alt="Alt text" /></p>

<p>它有以下7个方法可以被重写：
```java
public class Activity extends ApplicationContext {</p>

<pre><code>   protected void onCreate(Bundle savedInstanceState);  
   protected void onStart();     
   protected void onRestart();  
   protected void onResume();  
   protected void onPause();   
   protected void onStop();  
   protected void onDestroy();  
</code></pre>

<p>   }<br/>
<code>
也就是onCreate创建，onStart开始、onRestart重启、onResume恢复、onPause暂停、onStop停止和onDestory销毁时，这些方法都能够被重写，不难看出这些方法和Activity生命周期是息息相关的。
本例子就只要重写onCreate即可，看代码：
</code>java</p>

<pre><code>@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    setContentView(R.layout.main);
    mWebView = (WebView) findViewById(R.id.webview);

    WebSettings webSettings = mWebView.getSettings();
    webSettings.setSavePassword(false);

    webSettings.setSaveFormData(false);
    webSettings.setJavaScriptEnabled(true);
    webSettings.setSupportZoom(false);

    mWebView.setWebChromeClient(new MyWebChromeClient());

    mWebView.addJavascriptInterface(new DemoJavaScriptInterface(), "demo");

    mWebView.loadUrl("file:///android_asset/demo.html");
}
</code></pre>

<p>```
其中R.java这个为android的资源类，工程自动会维护这里暂时不用去考虑。首先是调用超类的onCreate方法来必要的初始化。然后设置试图为资源类的main。再来从资源类的webview中找到Id返回WebView类型的对象mWebView这个变量中。然后是WebSettings类对象webSettings的参数设置，这里setSavePassword和setSaveFormData代表不要保存表单控件的数据和密码，setJavaScriptEnabled设置为允许webview调用JavaScript，setSupportZoom设置为不允许缩放。由于要用到JavaScript，所以需要调用setWebChromeClient。</p>

<p>我们需要仔细看下addJavascriptInterface这个函数的说明</p>

<blockquote><p>Injects the supplied Java object into this WebView. The object is injected into the JavaScript context of the main frame, using the supplied name. This allows the Java object&rsquo;s methods to be accessed from JavaScript. For applications targeted to API level JELLY_BEAN_MR1 and above, only public methods that are annotated with JavascriptInterface can be accessed from JavaScript. For applications targeted to API level JELLY_BEAN or below, all public methods (including the inherited ones) can be accessed, see the important security note below for implications.</p></blockquote>

<p>我给翻译了下：它注入提供的Java对象到这个WebView。对象使用提供的名字注入JavaScript上下文的主要框架。这允许从JavaScript访问Java对象的方法。针对应用程序API级别在JELLY_BEAN_MR1以上的,只有JavascriptInterface的公共方法与注释可以从JavaScript访问。针对应用程序API级别或低于JELLY_BEAN的,所有公共方法(包括继承的)可以访问,参见下面重要的安全注意影响。</p>

<p>再看下2个参数，前一个为注入webview的Java对象（DemoJavaScriptInterface），后一个为暴露给JavaScript的对象名字（demo），本例中除了webview把点击消息传递给html，html中的JavaScript也要和webview交互，在哪里交互？伟大的google为我们想到JavaScript的顶层window对象，在下面动态创建了一个子对象，这里就是第二个参数demo，这个等等到了html再讲。</p>

<p>马上来看第一个参数的实现
```java</p>

<pre><code>final class DemoJavaScriptInterface {

    DemoJavaScriptInterface() {
    }

    /**
     * This is not called on the UI thread. Post a runnable to invoke
     * loadUrl on the UI thread.
     */
    public void clickOnAndroid() {
        mHandler.post(new Runnable() {
            public void run() {
                mWebView.loadUrl("javascript:wave()");
            }
        });

    }
}
</code></pre>

<p>```
直接一个构造函数什么都不做，然后直接用句柄提交实现了Runnable类的引用，再深入Runnable探究下</p>

<blockquote><p>The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. The class must define a method of no arguments called run.</p></blockquote>

<p>Runnable就一个方法，run给实现了就行，这里是直接调用demo.html页面里的JavaScript的wave方法。</p>

<p>看下一段代码
```java</p>

<pre><code>/**
 * Provides a hook for calling "alert" from javascript. Useful for
 * debugging your javascript.
 */
final class MyWebChromeClient extends WebChromeClient {
    @Override
    public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
        Log.d(LOG_TAG, message);
        result.confirm();
        return true;
    }
}
</code></pre>

<p>```
这里是对刚才指定的WebChromeClient对象MyWebChromeClient，进行onJsAlert的重写，可以看到其实就是在打印日志。</p>

<hr />

<h3>分析html部分代码</h3>

<p>app代码完了，再来看html
{% codeblock lang:html demo.html %}
<html></p>

<pre><code>&lt;script language="javascript"&gt;
    /* This function is invoked by the activity */
    function wave() {
        alert("1");
        document.getElementById("droid").src="android_waving.png";
        alert("2");
    }
&lt;/script&gt;
&lt;body&gt;
    &lt;!-- Calls into the javascript interface for the activity --&gt;
    &lt;a onClick="window.demo.clickOnAndroid()"&gt;&lt;div style="width:80px;
        margin:0px auto;
        padding:10px;
        text-align:center;
        border:2px solid #202020;" &gt;
            &lt;img id="droid" src="android_normal.png"/&gt;&lt;br&gt;
            Click me!
    &lt;/div&gt;&lt;/a&gt;
&lt;/body&gt;
</code></pre>

<p></html>
{% endcodeblock %}</p>

<p>注意看window.demo.clickOnAndroid这个JavaScript方法，刚刚我们在app代码里用addJavascriptInterface方法生成好了一个window.demo对象，就是通过这个对象，就可以调用app内置方法来实现网页的跳转。</p>

<h4>小结</h4>

<p>到此程序分析完毕,整个交互过程还是比较容易理解，就是先继承一个Activity类，关联好html页面，实现onCreate方法，在其中指定好app方法以及为javascript暴露对象名，然后进入html调用暴露的对象名及其方法进行跳转。</p>

<hr />

<p>最后，打开应用程序，它看起来应该像这样:)</p>

<p><img src="/images/evoup/android_webview_sample.png" alt="Alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Win7 Android开发环境搭建]]></title>
    <link href="http://evoupsight.com/blog/2014/01/17/android-adt-development-deloy/"/>
    <updated>2014-01-17T17:48:00+08:00</updated>
    <id>http://evoupsight.com/blog/2014/01/17/android-adt-development-deloy</id>
    <content type="html"><![CDATA[<p>最近有个HTML5的项目需要部署在android里，先研究下基本功，安装时还是遇到一些问题，如有的文章过时了，自己连搜索测试带整理写了一片文章备查。</p>

<!-- more -->


<h3>一、安装JDK</h3>

<p>安装JDK，我这里的windows7平台，先下载jdk7，然后安装，我的安装路径为C:\Program Files\Java\jdk1.7.0_25\。
安装完成后设置环境变量
开始->搜索程序和文件输入环境变量->编辑系统环境变量->添加以下环境变量：
<code>sh
JAVA_HOME值为：C:\Program Files\Java\jdk1.7.0_25\
CLASSPATH值为：.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\bin;
PATH值为：追加%JAVA_HOME%\bin;
</code></p>

<h3>二、安装Eclipse</h3>

<p>可以直接去www.eclipse.org下载，64位Windows平台下的下载地址：</p>

<p><a href="http://mirror.bit.edu.cn/eclipse/technology/epp/downloads/release/kepler/SR1/eclipse-cpp-kepler-SR1-win32-x86_64.zip">http://mirror.bit.edu.cn/eclipse/technology/epp/downloads/release/kepler/SR1/eclipse-cpp-kepler-SR1-win32-x86_64.zip</a></p>

<p>下载完成解压即可使用。见下图：
<img src="/images/evoup/eclipse_dir.png" alt="Alt text" /></p>

<h3>三、安装SDK</h3>

<p>首先去下载SDK,这个是等等用来和eclipse的adt插件关联的。</p>

<p>  下载地址如下：
  <a href="http://dl.google.com/android/adt/adt-bundle-windows-x86_64-20131030.zip">http://dl.google.com/android/adt/adt-bundle-windows-x86_64-20131030.zip</a></p>

<p>下载完成后我把它解压到C:\android\adt-bundle-windows-x86_64-20131030,运行adt-bundle-windows-x86_64-20131030下的SDK Manager.exe，勾选几个必要的API版本，Android4.2.2(API17)还有Android2.2(API8)，然后点击Install 11 package开始安装</p>

<p><img src="/images/evoup/adt_wait.png" alt="Alt text" /></p>

<p>如果速度慢，可以尝试用goagent代理进行加速,这里就提一下而以。</p>

<p><img src="/images/evoup/adt_use_proxy.png" alt="Alt text" /></p>

<p>等待下载完成</p>

<p><img src="/images/evoup/adt_done.png" alt="Alt text" /></p>

<h3>SDK配置</h3>

<p>接着把tools的路径C:\android\adt-bundle-windows-x86_64-20131030\sdk\tools追加到环境变量PATH中去。
要测试安装sdk是否成功，只需要运行cmd，然后输入
<code>sh
android -h
</code>
观察是否有输出正常信息，见下图：
<img src="/images/evoup/adt_installed.png" alt="Alt text" /></p>

<p>有其他教程说要设置SDK Location变量，我配置时发现其实不需要，估计是老版本了。</p>

<h3>Eclipse的ADT Package安装</h3>

<p>打开Eclipse，指定好工程的位置</p>

<p><img src="/images/evoup/adt_project_dir.png" alt="Alt text" /></p>

<p>选择 Help &lt; Install New Software 菜单。点击右上角的 Add 按钮，弹出 Add Repository 对话框，在 Name 一栏填写：“ADT Plugin”，在 Location 一栏填写：<a href="https://dl-ssl.google.com/android/eclipse/">https://dl-ssl.google.com/android/eclipse/</a></p>

<p>点击 OK。如果不能获取插件信息，就把 https 换成 http 试试。</p>

<p>然后整个勾选Developer Tools（最小安装的话至少要选择其下Android DDMS和Android Development Tools），点击Next，一路接受条款，等待安装插件完毕,中途可能出现安装警告，确认即可。</p>

<p><img src="/images/evoup/eclipse_adt_warning.png" alt="Alt text" /></p>

<p>之后重启Eclipse。</p>

<h3>Eclipse的ADT插件的配置</h3>

<p>安装完ADT插件并重启好Eclipse后，点击 Window &lt; Preferences 菜单，点击左侧菜单中的 Android，再点击右侧 Browse&hellip;，选择第3步中Android SDK的安装目录，设置完成后，点击 OK。</p>

<p><img src="/images/evoup/eclipse_adt_config.png" alt="Alt text" /></p>

<p>这样 Android 开发环境就搭建好了。</p>
]]></content>
  </entry>
  
</feed>
