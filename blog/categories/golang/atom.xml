<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Evoup`s Blog]]></title>
  <link href="http://evoupsight.com/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://evoupsight.com/"/>
  <updated>2013-12-31T17:24:29+08:00</updated>
  <id>http://evoupsight.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[golang的守护进程化]]></title>
    <link href="http://evoupsight.com/blog/2013/01/06/golang-daemonize/"/>
    <updated>2013-01-06T17:37:00+08:00</updated>
    <id>http://evoupsight.com/blog/2013/01/06/golang-daemonize</id>
    <content type="html"><![CDATA[<p>golang的守护进程化代码，参考了网上的代码，结合自己的项目，去掉了一些没用的代码，增加了fork时候的判断处理，我的机器是freebsd，fork会报errno:0,忽略，原因见代码注释。</p>

<!-- more -->


<p>```go
func Daemonize(nochdir, noclose int) error {
   var hLog *log.Logger
   hLog=LogInit();
   var ret, ret2 uintptr
   var err error
   Log( hLog, fmt.Sprintf(&ldquo;common.Daemonize][current ppid:%d&rdquo;, syscall.Getppid()) )</p>

<p>   //already a daemon
   if syscall.Getppid() == 1 {</p>

<pre><code>   return nil
</code></pre>

<p>   }
   Log(hLog,&ldquo;common.Daemonize][will daemonize&rdquo;)</p>

<p>   //fork off the parent process
   ret, ret2, err = syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)
   if err != nil {</p>

<pre><code>   var s string
   s=fmt.Sprintf("%T",err)
   if s != "syscall.Errno" {
       Log(hLog,"common.Daemonize][fork err:"+s)
           return err
   } else {
       Log(hLog,"common.Daemonize][fork no err:"+err.Error())
       //no problem see http://www.ibm.com/developerworks/aix/library/au-errnovariable/
   }
</code></pre>

<p>   }</p>

<p>   //failure
   if ret2 &lt; 0 {</p>

<pre><code>   os.Exit(-1)
</code></pre>

<p>   }</p>

<p>   //if we got a good PID, then we call exit the parent process.
   if ret > 0 {</p>

<pre><code>   os.Exit(0)
</code></pre>

<p>   }
   Log(hLog,&ldquo;common.Daemonize][forked,we in forked process&rdquo;)</p>

<p>   /<em> Change the file mode mask </em>/
   _ = syscall.Umask(0)
   Log(hLog,&ldquo;common.Daemonize][umask zero&rdquo;)</p>

<p>   //create a new SID for the child process
   s_ret, s_errno := syscall.Setsid()
   if s_ret &lt; 0 || s_errno != nil {</p>

<pre><code>   log.Printf("common.Daemonize][Error: syscall.Setsid errno: %d", s_errno)
</code></pre>

<p>   }
   Log(hLog,&ldquo;common.Daemonize][sid seted&rdquo;)</p>

<p>   if nochdir == 0 {</p>

<pre><code>   os.Chdir("/")
   Log(hLog,"common.Daemonize][chdir to root")
</code></pre>

<p>   }</p>

<p>   if noclose == 0 {</p>

<pre><code>   f, e := os.OpenFile("/dev/null", os.O_RDWR, 0)
   if e == nil {
       fd := f.Fd()
       syscall.Dup2(int(fd), int(os.Stdin.Fd()))
       syscall.Dup2(int(fd), int(os.Stdout.Fd()))
       syscall.Dup2(int(fd), int(os.Stderr.Fd()))
       Log(hLog,"common.Daemonize][fs closed")
   }
</code></pre>

<p>   }</p>

<p>   Log(hLog,&ldquo;common.Daemonize][daemonize done&rdquo;)
   return nil
}
```</p>
]]></content>
  </entry>
  
</feed>
